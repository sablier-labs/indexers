This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: .
- Files matching these patterns are excluded: src/abi/**, src/graph/common/bindings/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
bindings/
  SablierFlow_v1_0/
    ERC20.ts
    ERC20Bytes.ts
    SablierFlow.ts
  SablierFlow_v1_1/
    ERC20.ts
    ERC20Bytes.ts
    SablierFlow.ts
  schema.ts
helpers/
  amounts.ts
  index.ts
  types.ts
manifests/
  abstract.yaml
  arbitrum-one.yaml
  arbitrum-sepolia.yaml
  avalanche.yaml
  base-sepolia.yaml
  base.yaml
  berachain.yaml
  blast-mainnet.yaml
  bsc.yaml
  chiliz.yaml
  ethereum.yaml
  form.yaml
  gnosis.yaml
  iotex.yaml
  lightlink.yaml
  linea.yaml
  mode-mainnet.yaml
  optimism-sepolia.yaml
  optimism.yaml
  polygon.yaml
  scroll.yaml
  sei-mainnet.yaml
  sepolia.yaml
  unichain.yaml
  xdc.yaml
  zksync-sepolia.yaml
  zksync.yaml
mappings/
  common/
    adjust-stream.ts
    approval-for-all.ts
    approval.ts
    create-stream.ts
    deposit-stream.ts
    index.ts
    pause-stream.ts
    refund-stream.ts
    restart-stream.ts
    transfer.ts
    void-stream.ts
    withdraw-stream.ts
  v1.0/
    index.ts
  v1.1/
    index.ts
store/
  entity-action.ts
  entity-asset.ts
  entity-batch.ts
  entity-batcher.ts
  entity-stream.ts
  entity-watcher.ts
  index.ts
bindings.ts
justfile
schema.graphql

================================================================
Files
================================================================

================
File: bindings/SablierFlow_v1_0/ERC20.ts
================
// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt,
} from "@graphprotocol/graph-ts";

export class Approval extends ethereum.Event {
  get params(): Approval__Params {
    return new Approval__Params(this);
  }
}

export class Approval__Params {
  _event: Approval;

  constructor(event: Approval) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get spender(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Transfer extends ethereum.Event {
  get params(): Transfer__Params {
    return new Transfer__Params(this);
  }
}

export class Transfer__Params {
  _event: Transfer;

  constructor(event: Transfer) {
    this._event = event;
  }

  get from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class ERC20 extends ethereum.SmartContract {
  static bind(address: Address): ERC20 {
    return new ERC20("ERC20", address);
  }

  name(): string {
    let result = super.call("name", "name():(string)", []);

    return result[0].toString();
  }

  try_name(): ethereum.CallResult<string> {
    let result = super.tryCall("name", "name():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  symbol(): string {
    let result = super.call("symbol", "symbol():(string)", []);

    return result[0].toString();
  }

  try_symbol(): ethereum.CallResult<string> {
    let result = super.tryCall("symbol", "symbol():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  decimals(): i32 {
    let result = super.call("decimals", "decimals():(uint8)", []);

    return result[0].toI32();
  }

  try_decimals(): ethereum.CallResult<i32> {
    let result = super.tryCall("decimals", "decimals():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  totalSupply(): BigInt {
    let result = super.call("totalSupply", "totalSupply():(uint256)", []);

    return result[0].toBigInt();
  }

  try_totalSupply(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("totalSupply", "totalSupply():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  balanceOf(account: Address): BigInt {
    let result = super.call("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(account),
    ]);

    return result[0].toBigInt();
  }

  try_balanceOf(account: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(account),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  allowance(owner: Address, spender: Address): BigInt {
    let result = super.call(
      "allowance",
      "allowance(address,address):(uint256)",
      [ethereum.Value.fromAddress(owner), ethereum.Value.fromAddress(spender)],
    );

    return result[0].toBigInt();
  }

  try_allowance(owner: Address, spender: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "allowance",
      "allowance(address,address):(uint256)",
      [ethereum.Value.fromAddress(owner), ethereum.Value.fromAddress(spender)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  approve(spender: Address, amount: BigInt): boolean {
    let result = super.call("approve", "approve(address,uint256):(bool)", [
      ethereum.Value.fromAddress(spender),
      ethereum.Value.fromUnsignedBigInt(amount),
    ]);

    return result[0].toBoolean();
  }

  try_approve(spender: Address, amount: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("approve", "approve(address,uint256):(bool)", [
      ethereum.Value.fromAddress(spender),
      ethereum.Value.fromUnsignedBigInt(amount),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  transfer(recipient: Address, amount: BigInt): boolean {
    let result = super.call("transfer", "transfer(address,uint256):(bool)", [
      ethereum.Value.fromAddress(recipient),
      ethereum.Value.fromUnsignedBigInt(amount),
    ]);

    return result[0].toBoolean();
  }

  try_transfer(
    recipient: Address,
    amount: BigInt,
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall("transfer", "transfer(address,uint256):(bool)", [
      ethereum.Value.fromAddress(recipient),
      ethereum.Value.fromUnsignedBigInt(amount),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  transferFrom(sender: Address, recipient: Address, amount: BigInt): boolean {
    let result = super.call(
      "transferFrom",
      "transferFrom(address,address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(sender),
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(amount),
      ],
    );

    return result[0].toBoolean();
  }

  try_transferFrom(
    sender: Address,
    recipient: Address,
    amount: BigInt,
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "transferFrom",
      "transferFrom(address,address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(sender),
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(amount),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }
}

export class ApproveCall extends ethereum.Call {
  get inputs(): ApproveCall__Inputs {
    return new ApproveCall__Inputs(this);
  }

  get outputs(): ApproveCall__Outputs {
    return new ApproveCall__Outputs(this);
  }
}

export class ApproveCall__Inputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }

  get spender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ApproveCall__Outputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferCall extends ethereum.Call {
  get inputs(): TransferCall__Inputs {
    return new TransferCall__Inputs(this);
  }

  get outputs(): TransferCall__Outputs {
    return new TransferCall__Outputs(this);
  }
}

export class TransferCall__Inputs {
  _call: TransferCall;

  constructor(call: TransferCall) {
    this._call = call;
  }

  get recipient(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class TransferCall__Outputs {
  _call: TransferCall;

  constructor(call: TransferCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferFromCall extends ethereum.Call {
  get inputs(): TransferFromCall__Inputs {
    return new TransferFromCall__Inputs(this);
  }

  get outputs(): TransferFromCall__Outputs {
    return new TransferFromCall__Outputs(this);
  }
}

export class TransferFromCall__Inputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }

  get sender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get recipient(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class TransferFromCall__Outputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

================
File: bindings/SablierFlow_v1_0/ERC20Bytes.ts
================
// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt,
} from "@graphprotocol/graph-ts";

export class Approval extends ethereum.Event {
  get params(): Approval__Params {
    return new Approval__Params(this);
  }
}

export class Approval__Params {
  _event: Approval;

  constructor(event: Approval) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get spender(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Transfer extends ethereum.Event {
  get params(): Transfer__Params {
    return new Transfer__Params(this);
  }
}

export class Transfer__Params {
  _event: Transfer;

  constructor(event: Transfer) {
    this._event = event;
  }

  get from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class ERC20Bytes extends ethereum.SmartContract {
  static bind(address: Address): ERC20Bytes {
    return new ERC20Bytes("ERC20Bytes", address);
  }

  name(): Bytes {
    let result = super.call("name", "name():(bytes32)", []);

    return result[0].toBytes();
  }

  try_name(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("name", "name():(bytes32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  symbol(): Bytes {
    let result = super.call("symbol", "symbol():(bytes32)", []);

    return result[0].toBytes();
  }

  try_symbol(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("symbol", "symbol():(bytes32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  decimals(): i32 {
    let result = super.call("decimals", "decimals():(uint8)", []);

    return result[0].toI32();
  }

  try_decimals(): ethereum.CallResult<i32> {
    let result = super.tryCall("decimals", "decimals():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  totalSupply(): BigInt {
    let result = super.call("totalSupply", "totalSupply():(uint256)", []);

    return result[0].toBigInt();
  }

  try_totalSupply(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("totalSupply", "totalSupply():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  balanceOf(account: Address): BigInt {
    let result = super.call("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(account),
    ]);

    return result[0].toBigInt();
  }

  try_balanceOf(account: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(account),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  allowance(owner: Address, spender: Address): BigInt {
    let result = super.call(
      "allowance",
      "allowance(address,address):(uint256)",
      [ethereum.Value.fromAddress(owner), ethereum.Value.fromAddress(spender)],
    );

    return result[0].toBigInt();
  }

  try_allowance(owner: Address, spender: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "allowance",
      "allowance(address,address):(uint256)",
      [ethereum.Value.fromAddress(owner), ethereum.Value.fromAddress(spender)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  approve(spender: Address, amount: BigInt): boolean {
    let result = super.call("approve", "approve(address,uint256):(bool)", [
      ethereum.Value.fromAddress(spender),
      ethereum.Value.fromUnsignedBigInt(amount),
    ]);

    return result[0].toBoolean();
  }

  try_approve(spender: Address, amount: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("approve", "approve(address,uint256):(bool)", [
      ethereum.Value.fromAddress(spender),
      ethereum.Value.fromUnsignedBigInt(amount),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  transfer(recipient: Address, amount: BigInt): boolean {
    let result = super.call("transfer", "transfer(address,uint256):(bool)", [
      ethereum.Value.fromAddress(recipient),
      ethereum.Value.fromUnsignedBigInt(amount),
    ]);

    return result[0].toBoolean();
  }

  try_transfer(
    recipient: Address,
    amount: BigInt,
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall("transfer", "transfer(address,uint256):(bool)", [
      ethereum.Value.fromAddress(recipient),
      ethereum.Value.fromUnsignedBigInt(amount),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  transferFrom(sender: Address, recipient: Address, amount: BigInt): boolean {
    let result = super.call(
      "transferFrom",
      "transferFrom(address,address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(sender),
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(amount),
      ],
    );

    return result[0].toBoolean();
  }

  try_transferFrom(
    sender: Address,
    recipient: Address,
    amount: BigInt,
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "transferFrom",
      "transferFrom(address,address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(sender),
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(amount),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }
}

export class ApproveCall extends ethereum.Call {
  get inputs(): ApproveCall__Inputs {
    return new ApproveCall__Inputs(this);
  }

  get outputs(): ApproveCall__Outputs {
    return new ApproveCall__Outputs(this);
  }
}

export class ApproveCall__Inputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }

  get spender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ApproveCall__Outputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferCall extends ethereum.Call {
  get inputs(): TransferCall__Inputs {
    return new TransferCall__Inputs(this);
  }

  get outputs(): TransferCall__Outputs {
    return new TransferCall__Outputs(this);
  }
}

export class TransferCall__Inputs {
  _call: TransferCall;

  constructor(call: TransferCall) {
    this._call = call;
  }

  get recipient(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class TransferCall__Outputs {
  _call: TransferCall;

  constructor(call: TransferCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferFromCall extends ethereum.Call {
  get inputs(): TransferFromCall__Inputs {
    return new TransferFromCall__Inputs(this);
  }

  get outputs(): TransferFromCall__Outputs {
    return new TransferFromCall__Outputs(this);
  }
}

export class TransferFromCall__Inputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }

  get sender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get recipient(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class TransferFromCall__Outputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

================
File: bindings/SablierFlow_v1_0/SablierFlow.ts
================
// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt,
} from "@graphprotocol/graph-ts";

export class AdjustFlowStream extends ethereum.Event {
  get params(): AdjustFlowStream__Params {
    return new AdjustFlowStream__Params(this);
  }
}

export class AdjustFlowStream__Params {
  _event: AdjustFlowStream;

  constructor(event: AdjustFlowStream) {
    this._event = event;
  }

  get streamId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get totalDebt(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get oldRatePerSecond(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get newRatePerSecond(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class Approval extends ethereum.Event {
  get params(): Approval__Params {
    return new Approval__Params(this);
  }
}

export class Approval__Params {
  _event: Approval;

  constructor(event: Approval) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get approved(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get tokenId(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class ApprovalForAll extends ethereum.Event {
  get params(): ApprovalForAll__Params {
    return new ApprovalForAll__Params(this);
  }
}

export class ApprovalForAll__Params {
  _event: ApprovalForAll;

  constructor(event: ApprovalForAll) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get operator(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get approved(): boolean {
    return this._event.parameters[2].value.toBoolean();
  }
}

export class BatchMetadataUpdate extends ethereum.Event {
  get params(): BatchMetadataUpdate__Params {
    return new BatchMetadataUpdate__Params(this);
  }
}

export class BatchMetadataUpdate__Params {
  _event: BatchMetadataUpdate;

  constructor(event: BatchMetadataUpdate) {
    this._event = event;
  }

  get _fromTokenId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get _toTokenId(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class CollectProtocolRevenue extends ethereum.Event {
  get params(): CollectProtocolRevenue__Params {
    return new CollectProtocolRevenue__Params(this);
  }
}

export class CollectProtocolRevenue__Params {
  _event: CollectProtocolRevenue;

  constructor(event: CollectProtocolRevenue) {
    this._event = event;
  }

  get admin(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get token(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get revenue(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class CreateFlowStream extends ethereum.Event {
  get params(): CreateFlowStream__Params {
    return new CreateFlowStream__Params(this);
  }
}

export class CreateFlowStream__Params {
  _event: CreateFlowStream;

  constructor(event: CreateFlowStream) {
    this._event = event;
  }

  get streamId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get sender(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get recipient(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get ratePerSecond(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get token(): Address {
    return this._event.parameters[4].value.toAddress();
  }

  get transferable(): boolean {
    return this._event.parameters[5].value.toBoolean();
  }
}

export class DepositFlowStream extends ethereum.Event {
  get params(): DepositFlowStream__Params {
    return new DepositFlowStream__Params(this);
  }
}

export class DepositFlowStream__Params {
  _event: DepositFlowStream;

  constructor(event: DepositFlowStream) {
    this._event = event;
  }

  get streamId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get funder(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class MetadataUpdate extends ethereum.Event {
  get params(): MetadataUpdate__Params {
    return new MetadataUpdate__Params(this);
  }
}

export class MetadataUpdate__Params {
  _event: MetadataUpdate;

  constructor(event: MetadataUpdate) {
    this._event = event;
  }

  get _tokenId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class PauseFlowStream extends ethereum.Event {
  get params(): PauseFlowStream__Params {
    return new PauseFlowStream__Params(this);
  }
}

export class PauseFlowStream__Params {
  _event: PauseFlowStream;

  constructor(event: PauseFlowStream) {
    this._event = event;
  }

  get streamId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get sender(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get recipient(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get totalDebt(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class Recover extends ethereum.Event {
  get params(): Recover__Params {
    return new Recover__Params(this);
  }
}

export class Recover__Params {
  _event: Recover;

  constructor(event: Recover) {
    this._event = event;
  }

  get admin(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get token(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get surplus(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class RefundFromFlowStream extends ethereum.Event {
  get params(): RefundFromFlowStream__Params {
    return new RefundFromFlowStream__Params(this);
  }
}

export class RefundFromFlowStream__Params {
  _event: RefundFromFlowStream;

  constructor(event: RefundFromFlowStream) {
    this._event = event;
  }

  get streamId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get sender(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class RestartFlowStream extends ethereum.Event {
  get params(): RestartFlowStream__Params {
    return new RestartFlowStream__Params(this);
  }
}

export class RestartFlowStream__Params {
  _event: RestartFlowStream;

  constructor(event: RestartFlowStream) {
    this._event = event;
  }

  get streamId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get sender(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get ratePerSecond(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class SetNFTDescriptor extends ethereum.Event {
  get params(): SetNFTDescriptor__Params {
    return new SetNFTDescriptor__Params(this);
  }
}

export class SetNFTDescriptor__Params {
  _event: SetNFTDescriptor;

  constructor(event: SetNFTDescriptor) {
    this._event = event;
  }

  get admin(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get oldNFTDescriptor(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get newNFTDescriptor(): Address {
    return this._event.parameters[2].value.toAddress();
  }
}

export class SetProtocolFee extends ethereum.Event {
  get params(): SetProtocolFee__Params {
    return new SetProtocolFee__Params(this);
  }
}

export class SetProtocolFee__Params {
  _event: SetProtocolFee;

  constructor(event: SetProtocolFee) {
    this._event = event;
  }

  get admin(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get token(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get oldProtocolFee(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get newProtocolFee(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class Transfer extends ethereum.Event {
  get params(): Transfer__Params {
    return new Transfer__Params(this);
  }
}

export class Transfer__Params {
  _event: Transfer;

  constructor(event: Transfer) {
    this._event = event;
  }

  get from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get tokenId(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class TransferAdmin extends ethereum.Event {
  get params(): TransferAdmin__Params {
    return new TransferAdmin__Params(this);
  }
}

export class TransferAdmin__Params {
  _event: TransferAdmin;

  constructor(event: TransferAdmin) {
    this._event = event;
  }

  get oldAdmin(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newAdmin(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class VoidFlowStream extends ethereum.Event {
  get params(): VoidFlowStream__Params {
    return new VoidFlowStream__Params(this);
  }
}

export class VoidFlowStream__Params {
  _event: VoidFlowStream;

  constructor(event: VoidFlowStream) {
    this._event = event;
  }

  get streamId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get sender(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get recipient(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get caller(): Address {
    return this._event.parameters[3].value.toAddress();
  }

  get newTotalDebt(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }

  get writtenOffDebt(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }
}

export class WithdrawFromFlowStream extends ethereum.Event {
  get params(): WithdrawFromFlowStream__Params {
    return new WithdrawFromFlowStream__Params(this);
  }
}

export class WithdrawFromFlowStream__Params {
  _event: WithdrawFromFlowStream;

  constructor(event: WithdrawFromFlowStream) {
    this._event = event;
  }

  get streamId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get to(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get token(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get caller(): Address {
    return this._event.parameters[3].value.toAddress();
  }

  get withdrawAmount(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }

  get protocolFeeAmount(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }
}

export class SablierFlow extends ethereum.SmartContract {
  static bind(address: Address): SablierFlow {
    return new SablierFlow("SablierFlow", address);
  }

  admin(): Address {
    let result = super.call("admin", "admin():(address)", []);

    return result[0].toAddress();
  }

  try_admin(): ethereum.CallResult<Address> {
    let result = super.tryCall("admin", "admin():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

================
File: bindings/SablierFlow_v1_1/ERC20.ts
================
// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt,
} from "@graphprotocol/graph-ts";

export class Approval extends ethereum.Event {
  get params(): Approval__Params {
    return new Approval__Params(this);
  }
}

export class Approval__Params {
  _event: Approval;

  constructor(event: Approval) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get spender(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Transfer extends ethereum.Event {
  get params(): Transfer__Params {
    return new Transfer__Params(this);
  }
}

export class Transfer__Params {
  _event: Transfer;

  constructor(event: Transfer) {
    this._event = event;
  }

  get from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class ERC20 extends ethereum.SmartContract {
  static bind(address: Address): ERC20 {
    return new ERC20("ERC20", address);
  }

  name(): string {
    let result = super.call("name", "name():(string)", []);

    return result[0].toString();
  }

  try_name(): ethereum.CallResult<string> {
    let result = super.tryCall("name", "name():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  symbol(): string {
    let result = super.call("symbol", "symbol():(string)", []);

    return result[0].toString();
  }

  try_symbol(): ethereum.CallResult<string> {
    let result = super.tryCall("symbol", "symbol():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  decimals(): i32 {
    let result = super.call("decimals", "decimals():(uint8)", []);

    return result[0].toI32();
  }

  try_decimals(): ethereum.CallResult<i32> {
    let result = super.tryCall("decimals", "decimals():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  totalSupply(): BigInt {
    let result = super.call("totalSupply", "totalSupply():(uint256)", []);

    return result[0].toBigInt();
  }

  try_totalSupply(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("totalSupply", "totalSupply():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  balanceOf(account: Address): BigInt {
    let result = super.call("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(account),
    ]);

    return result[0].toBigInt();
  }

  try_balanceOf(account: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(account),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  allowance(owner: Address, spender: Address): BigInt {
    let result = super.call(
      "allowance",
      "allowance(address,address):(uint256)",
      [ethereum.Value.fromAddress(owner), ethereum.Value.fromAddress(spender)],
    );

    return result[0].toBigInt();
  }

  try_allowance(owner: Address, spender: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "allowance",
      "allowance(address,address):(uint256)",
      [ethereum.Value.fromAddress(owner), ethereum.Value.fromAddress(spender)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  approve(spender: Address, amount: BigInt): boolean {
    let result = super.call("approve", "approve(address,uint256):(bool)", [
      ethereum.Value.fromAddress(spender),
      ethereum.Value.fromUnsignedBigInt(amount),
    ]);

    return result[0].toBoolean();
  }

  try_approve(spender: Address, amount: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("approve", "approve(address,uint256):(bool)", [
      ethereum.Value.fromAddress(spender),
      ethereum.Value.fromUnsignedBigInt(amount),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  transfer(recipient: Address, amount: BigInt): boolean {
    let result = super.call("transfer", "transfer(address,uint256):(bool)", [
      ethereum.Value.fromAddress(recipient),
      ethereum.Value.fromUnsignedBigInt(amount),
    ]);

    return result[0].toBoolean();
  }

  try_transfer(
    recipient: Address,
    amount: BigInt,
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall("transfer", "transfer(address,uint256):(bool)", [
      ethereum.Value.fromAddress(recipient),
      ethereum.Value.fromUnsignedBigInt(amount),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  transferFrom(sender: Address, recipient: Address, amount: BigInt): boolean {
    let result = super.call(
      "transferFrom",
      "transferFrom(address,address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(sender),
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(amount),
      ],
    );

    return result[0].toBoolean();
  }

  try_transferFrom(
    sender: Address,
    recipient: Address,
    amount: BigInt,
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "transferFrom",
      "transferFrom(address,address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(sender),
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(amount),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }
}

export class ApproveCall extends ethereum.Call {
  get inputs(): ApproveCall__Inputs {
    return new ApproveCall__Inputs(this);
  }

  get outputs(): ApproveCall__Outputs {
    return new ApproveCall__Outputs(this);
  }
}

export class ApproveCall__Inputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }

  get spender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ApproveCall__Outputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferCall extends ethereum.Call {
  get inputs(): TransferCall__Inputs {
    return new TransferCall__Inputs(this);
  }

  get outputs(): TransferCall__Outputs {
    return new TransferCall__Outputs(this);
  }
}

export class TransferCall__Inputs {
  _call: TransferCall;

  constructor(call: TransferCall) {
    this._call = call;
  }

  get recipient(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class TransferCall__Outputs {
  _call: TransferCall;

  constructor(call: TransferCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferFromCall extends ethereum.Call {
  get inputs(): TransferFromCall__Inputs {
    return new TransferFromCall__Inputs(this);
  }

  get outputs(): TransferFromCall__Outputs {
    return new TransferFromCall__Outputs(this);
  }
}

export class TransferFromCall__Inputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }

  get sender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get recipient(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class TransferFromCall__Outputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

================
File: bindings/SablierFlow_v1_1/ERC20Bytes.ts
================
// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt,
} from "@graphprotocol/graph-ts";

export class Approval extends ethereum.Event {
  get params(): Approval__Params {
    return new Approval__Params(this);
  }
}

export class Approval__Params {
  _event: Approval;

  constructor(event: Approval) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get spender(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Transfer extends ethereum.Event {
  get params(): Transfer__Params {
    return new Transfer__Params(this);
  }
}

export class Transfer__Params {
  _event: Transfer;

  constructor(event: Transfer) {
    this._event = event;
  }

  get from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class ERC20Bytes extends ethereum.SmartContract {
  static bind(address: Address): ERC20Bytes {
    return new ERC20Bytes("ERC20Bytes", address);
  }

  name(): Bytes {
    let result = super.call("name", "name():(bytes32)", []);

    return result[0].toBytes();
  }

  try_name(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("name", "name():(bytes32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  symbol(): Bytes {
    let result = super.call("symbol", "symbol():(bytes32)", []);

    return result[0].toBytes();
  }

  try_symbol(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("symbol", "symbol():(bytes32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  decimals(): i32 {
    let result = super.call("decimals", "decimals():(uint8)", []);

    return result[0].toI32();
  }

  try_decimals(): ethereum.CallResult<i32> {
    let result = super.tryCall("decimals", "decimals():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  totalSupply(): BigInt {
    let result = super.call("totalSupply", "totalSupply():(uint256)", []);

    return result[0].toBigInt();
  }

  try_totalSupply(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("totalSupply", "totalSupply():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  balanceOf(account: Address): BigInt {
    let result = super.call("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(account),
    ]);

    return result[0].toBigInt();
  }

  try_balanceOf(account: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(account),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  allowance(owner: Address, spender: Address): BigInt {
    let result = super.call(
      "allowance",
      "allowance(address,address):(uint256)",
      [ethereum.Value.fromAddress(owner), ethereum.Value.fromAddress(spender)],
    );

    return result[0].toBigInt();
  }

  try_allowance(owner: Address, spender: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "allowance",
      "allowance(address,address):(uint256)",
      [ethereum.Value.fromAddress(owner), ethereum.Value.fromAddress(spender)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  approve(spender: Address, amount: BigInt): boolean {
    let result = super.call("approve", "approve(address,uint256):(bool)", [
      ethereum.Value.fromAddress(spender),
      ethereum.Value.fromUnsignedBigInt(amount),
    ]);

    return result[0].toBoolean();
  }

  try_approve(spender: Address, amount: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("approve", "approve(address,uint256):(bool)", [
      ethereum.Value.fromAddress(spender),
      ethereum.Value.fromUnsignedBigInt(amount),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  transfer(recipient: Address, amount: BigInt): boolean {
    let result = super.call("transfer", "transfer(address,uint256):(bool)", [
      ethereum.Value.fromAddress(recipient),
      ethereum.Value.fromUnsignedBigInt(amount),
    ]);

    return result[0].toBoolean();
  }

  try_transfer(
    recipient: Address,
    amount: BigInt,
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall("transfer", "transfer(address,uint256):(bool)", [
      ethereum.Value.fromAddress(recipient),
      ethereum.Value.fromUnsignedBigInt(amount),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  transferFrom(sender: Address, recipient: Address, amount: BigInt): boolean {
    let result = super.call(
      "transferFrom",
      "transferFrom(address,address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(sender),
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(amount),
      ],
    );

    return result[0].toBoolean();
  }

  try_transferFrom(
    sender: Address,
    recipient: Address,
    amount: BigInt,
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "transferFrom",
      "transferFrom(address,address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(sender),
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(amount),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }
}

export class ApproveCall extends ethereum.Call {
  get inputs(): ApproveCall__Inputs {
    return new ApproveCall__Inputs(this);
  }

  get outputs(): ApproveCall__Outputs {
    return new ApproveCall__Outputs(this);
  }
}

export class ApproveCall__Inputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }

  get spender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ApproveCall__Outputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferCall extends ethereum.Call {
  get inputs(): TransferCall__Inputs {
    return new TransferCall__Inputs(this);
  }

  get outputs(): TransferCall__Outputs {
    return new TransferCall__Outputs(this);
  }
}

export class TransferCall__Inputs {
  _call: TransferCall;

  constructor(call: TransferCall) {
    this._call = call;
  }

  get recipient(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class TransferCall__Outputs {
  _call: TransferCall;

  constructor(call: TransferCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferFromCall extends ethereum.Call {
  get inputs(): TransferFromCall__Inputs {
    return new TransferFromCall__Inputs(this);
  }

  get outputs(): TransferFromCall__Outputs {
    return new TransferFromCall__Outputs(this);
  }
}

export class TransferFromCall__Inputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }

  get sender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get recipient(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class TransferFromCall__Outputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

================
File: bindings/SablierFlow_v1_1/SablierFlow.ts
================
// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt,
} from "@graphprotocol/graph-ts";

export class AdjustFlowStream extends ethereum.Event {
  get params(): AdjustFlowStream__Params {
    return new AdjustFlowStream__Params(this);
  }
}

export class AdjustFlowStream__Params {
  _event: AdjustFlowStream;

  constructor(event: AdjustFlowStream) {
    this._event = event;
  }

  get streamId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get totalDebt(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get oldRatePerSecond(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get newRatePerSecond(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class Approval extends ethereum.Event {
  get params(): Approval__Params {
    return new Approval__Params(this);
  }
}

export class Approval__Params {
  _event: Approval;

  constructor(event: Approval) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get approved(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get tokenId(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class ApprovalForAll extends ethereum.Event {
  get params(): ApprovalForAll__Params {
    return new ApprovalForAll__Params(this);
  }
}

export class ApprovalForAll__Params {
  _event: ApprovalForAll;

  constructor(event: ApprovalForAll) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get operator(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get approved(): boolean {
    return this._event.parameters[2].value.toBoolean();
  }
}

export class BatchMetadataUpdate extends ethereum.Event {
  get params(): BatchMetadataUpdate__Params {
    return new BatchMetadataUpdate__Params(this);
  }
}

export class BatchMetadataUpdate__Params {
  _event: BatchMetadataUpdate;

  constructor(event: BatchMetadataUpdate) {
    this._event = event;
  }

  get _fromTokenId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get _toTokenId(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class CollectProtocolRevenue extends ethereum.Event {
  get params(): CollectProtocolRevenue__Params {
    return new CollectProtocolRevenue__Params(this);
  }
}

export class CollectProtocolRevenue__Params {
  _event: CollectProtocolRevenue;

  constructor(event: CollectProtocolRevenue) {
    this._event = event;
  }

  get admin(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get token(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get revenue(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class CreateFlowStream extends ethereum.Event {
  get params(): CreateFlowStream__Params {
    return new CreateFlowStream__Params(this);
  }
}

export class CreateFlowStream__Params {
  _event: CreateFlowStream;

  constructor(event: CreateFlowStream) {
    this._event = event;
  }

  get streamId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get sender(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get recipient(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get ratePerSecond(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get token(): Address {
    return this._event.parameters[4].value.toAddress();
  }

  get transferable(): boolean {
    return this._event.parameters[5].value.toBoolean();
  }
}

export class DepositFlowStream extends ethereum.Event {
  get params(): DepositFlowStream__Params {
    return new DepositFlowStream__Params(this);
  }
}

export class DepositFlowStream__Params {
  _event: DepositFlowStream;

  constructor(event: DepositFlowStream) {
    this._event = event;
  }

  get streamId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get funder(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class MetadataUpdate extends ethereum.Event {
  get params(): MetadataUpdate__Params {
    return new MetadataUpdate__Params(this);
  }
}

export class MetadataUpdate__Params {
  _event: MetadataUpdate;

  constructor(event: MetadataUpdate) {
    this._event = event;
  }

  get _tokenId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class PauseFlowStream extends ethereum.Event {
  get params(): PauseFlowStream__Params {
    return new PauseFlowStream__Params(this);
  }
}

export class PauseFlowStream__Params {
  _event: PauseFlowStream;

  constructor(event: PauseFlowStream) {
    this._event = event;
  }

  get streamId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get sender(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get recipient(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get totalDebt(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class Recover extends ethereum.Event {
  get params(): Recover__Params {
    return new Recover__Params(this);
  }
}

export class Recover__Params {
  _event: Recover;

  constructor(event: Recover) {
    this._event = event;
  }

  get admin(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get token(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get surplus(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class RefundFromFlowStream extends ethereum.Event {
  get params(): RefundFromFlowStream__Params {
    return new RefundFromFlowStream__Params(this);
  }
}

export class RefundFromFlowStream__Params {
  _event: RefundFromFlowStream;

  constructor(event: RefundFromFlowStream) {
    this._event = event;
  }

  get streamId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get sender(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class RestartFlowStream extends ethereum.Event {
  get params(): RestartFlowStream__Params {
    return new RestartFlowStream__Params(this);
  }
}

export class RestartFlowStream__Params {
  _event: RestartFlowStream;

  constructor(event: RestartFlowStream) {
    this._event = event;
  }

  get streamId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get sender(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get ratePerSecond(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class SetNFTDescriptor extends ethereum.Event {
  get params(): SetNFTDescriptor__Params {
    return new SetNFTDescriptor__Params(this);
  }
}

export class SetNFTDescriptor__Params {
  _event: SetNFTDescriptor;

  constructor(event: SetNFTDescriptor) {
    this._event = event;
  }

  get admin(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get oldNFTDescriptor(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get newNFTDescriptor(): Address {
    return this._event.parameters[2].value.toAddress();
  }
}

export class SetProtocolFee extends ethereum.Event {
  get params(): SetProtocolFee__Params {
    return new SetProtocolFee__Params(this);
  }
}

export class SetProtocolFee__Params {
  _event: SetProtocolFee;

  constructor(event: SetProtocolFee) {
    this._event = event;
  }

  get admin(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get token(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get oldProtocolFee(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get newProtocolFee(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class Transfer extends ethereum.Event {
  get params(): Transfer__Params {
    return new Transfer__Params(this);
  }
}

export class Transfer__Params {
  _event: Transfer;

  constructor(event: Transfer) {
    this._event = event;
  }

  get from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get tokenId(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class TransferAdmin extends ethereum.Event {
  get params(): TransferAdmin__Params {
    return new TransferAdmin__Params(this);
  }
}

export class TransferAdmin__Params {
  _event: TransferAdmin;

  constructor(event: TransferAdmin) {
    this._event = event;
  }

  get oldAdmin(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newAdmin(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class VoidFlowStream extends ethereum.Event {
  get params(): VoidFlowStream__Params {
    return new VoidFlowStream__Params(this);
  }
}

export class VoidFlowStream__Params {
  _event: VoidFlowStream;

  constructor(event: VoidFlowStream) {
    this._event = event;
  }

  get streamId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get sender(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get recipient(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get caller(): Address {
    return this._event.parameters[3].value.toAddress();
  }

  get newTotalDebt(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }

  get writtenOffDebt(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }
}

export class WithdrawFromFlowStream extends ethereum.Event {
  get params(): WithdrawFromFlowStream__Params {
    return new WithdrawFromFlowStream__Params(this);
  }
}

export class WithdrawFromFlowStream__Params {
  _event: WithdrawFromFlowStream;

  constructor(event: WithdrawFromFlowStream) {
    this._event = event;
  }

  get streamId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get to(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get token(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get caller(): Address {
    return this._event.parameters[3].value.toAddress();
  }

  get withdrawAmount(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }

  get protocolFeeAmount(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }
}

export class SablierFlow extends ethereum.SmartContract {
  static bind(address: Address): SablierFlow {
    return new SablierFlow("SablierFlow", address);
  }

  admin(): Address {
    let result = super.call("admin", "admin():(address)", []);

    return result[0].toAddress();
  }

  try_admin(): ethereum.CallResult<Address> {
    let result = super.tryCall("admin", "admin():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

================
File: bindings/schema.ts
================
// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal,
  Int8,
} from "@graphprotocol/graph-ts";

export class Action extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Action entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Action must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Action", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Action | null {
    return changetype<Action | null>(store.get_in_block("Action", id));
  }

  static load(id: string): Action | null {
    return changetype<Action | null>(store.get("Action", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get subgraphId(): BigInt {
    let value = this.get("subgraphId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set subgraphId(value: BigInt) {
    this.set("subgraphId", Value.fromBigInt(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get chainId(): BigInt {
    let value = this.get("chainId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set chainId(value: BigInt) {
    this.set("chainId", Value.fromBigInt(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get hash(): Bytes {
    let value = this.get("hash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set hash(value: Bytes) {
    this.set("hash", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get category(): string {
    let value = this.get("category");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set category(value: string) {
    this.set("category", Value.fromString(value));
  }

  get contract(): Bytes {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contract(value: Bytes) {
    this.set("contract", Value.fromBytes(value));
  }

  get fee(): BigInt | null {
    let value = this.get("fee");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set fee(value: BigInt | null) {
    if (!value) {
      this.unset("fee");
    } else {
      this.set("fee", Value.fromBigInt(<BigInt>value));
    }
  }

  get stream(): string | null {
    let value = this.get("stream");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set stream(value: string | null) {
    if (!value) {
      this.unset("stream");
    } else {
      this.set("stream", Value.fromString(<string>value));
    }
  }

  get addressA(): Bytes | null {
    let value = this.get("addressA");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set addressA(value: Bytes | null) {
    if (!value) {
      this.unset("addressA");
    } else {
      this.set("addressA", Value.fromBytes(<Bytes>value));
    }
  }

  get addressB(): Bytes | null {
    let value = this.get("addressB");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set addressB(value: Bytes | null) {
    if (!value) {
      this.unset("addressB");
    } else {
      this.set("addressB", Value.fromBytes(<Bytes>value));
    }
  }

  get amountA(): BigInt | null {
    let value = this.get("amountA");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set amountA(value: BigInt | null) {
    if (!value) {
      this.unset("amountA");
    } else {
      this.set("amountA", Value.fromBigInt(<BigInt>value));
    }
  }

  get amountB(): BigInt | null {
    let value = this.get("amountB");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set amountB(value: BigInt | null) {
    if (!value) {
      this.unset("amountB");
    } else {
      this.set("amountB", Value.fromBigInt(<BigInt>value));
    }
  }
}

export class Batch extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Batch entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Batch must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Batch", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Batch | null {
    return changetype<Batch | null>(store.get_in_block("Batch", id));
  }

  static load(id: string): Batch | null {
    return changetype<Batch | null>(store.get("Batch", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get hash(): Bytes | null {
    let value = this.get("hash");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set hash(value: Bytes | null) {
    if (!value) {
      this.unset("hash");
    } else {
      this.set("hash", Value.fromBytes(<Bytes>value));
    }
  }

  get timestamp(): BigInt | null {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt | null) {
    if (!value) {
      this.unset("timestamp");
    } else {
      this.set("timestamp", Value.fromBigInt(<BigInt>value));
    }
  }

  get batcher(): string | null {
    let value = this.get("batcher");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set batcher(value: string | null) {
    if (!value) {
      this.unset("batcher");
    } else {
      this.set("batcher", Value.fromString(<string>value));
    }
  }

  get size(): BigInt {
    let value = this.get("size");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set size(value: BigInt) {
    this.set("size", Value.fromBigInt(value));
  }

  get streams(): StreamLoader {
    return new StreamLoader("Batch", this.get("id")!.toString(), "streams");
  }
}

export class Batcher extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Batcher entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Batcher must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Batcher", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Batcher | null {
    return changetype<Batcher | null>(store.get_in_block("Batcher", id));
  }

  static load(id: string): Batcher | null {
    return changetype<Batcher | null>(store.get("Batcher", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get batchCounter(): BigInt {
    let value = this.get("batchCounter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set batchCounter(value: BigInt) {
    this.set("batchCounter", Value.fromBigInt(value));
  }

  get batches(): BatchLoader {
    return new BatchLoader("Batcher", this.get("id")!.toString(), "batches");
  }
}

export class Asset extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Asset entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Asset must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Asset", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Asset | null {
    return changetype<Asset | null>(store.get_in_block("Asset", id));
  }

  static load(id: string): Asset | null {
    return changetype<Asset | null>(store.get("Asset", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get chainId(): BigInt {
    let value = this.get("chainId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set chainId(value: BigInt) {
    this.set("chainId", Value.fromBigInt(value));
  }

  get decimals(): BigInt {
    let value = this.get("decimals");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set decimals(value: BigInt) {
    this.set("decimals", Value.fromBigInt(value));
  }

  get name(): string {
    let value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get symbol(): string {
    let value = this.get("symbol");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set symbol(value: string) {
    this.set("symbol", Value.fromString(value));
  }

  get streams(): StreamLoader {
    return new StreamLoader("Asset", this.get("id")!.toString(), "streams");
  }
}

export class Watcher extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Watcher entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Watcher must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Watcher", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Watcher | null {
    return changetype<Watcher | null>(store.get_in_block("Watcher", id));
  }

  static load(id: string): Watcher | null {
    return changetype<Watcher | null>(store.get("Watcher", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get actionCounter(): BigInt {
    let value = this.get("actionCounter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set actionCounter(value: BigInt) {
    this.set("actionCounter", Value.fromBigInt(value));
  }

  get chainId(): BigInt {
    let value = this.get("chainId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set chainId(value: BigInt) {
    this.set("chainId", Value.fromBigInt(value));
  }

  get logs(): Array<string> | null {
    let value = this.get("logs");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toStringArray();
    }
  }

  set logs(value: Array<string> | null) {
    if (!value) {
      this.unset("logs");
    } else {
      this.set("logs", Value.fromStringArray(<Array<string>>value));
    }
  }

  get streamCounter(): BigInt {
    let value = this.get("streamCounter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set streamCounter(value: BigInt) {
    this.set("streamCounter", Value.fromBigInt(value));
  }
}

export class Stream extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Stream entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Stream must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Stream", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Stream | null {
    return changetype<Stream | null>(store.get_in_block("Stream", id));
  }

  static load(id: string): Stream | null {
    return changetype<Stream | null>(store.get("Stream", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get alias(): string {
    let value = this.get("alias");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set alias(value: string) {
    this.set("alias", Value.fromString(value));
  }

  get chainId(): BigInt {
    let value = this.get("chainId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set chainId(value: BigInt) {
    this.set("chainId", Value.fromBigInt(value));
  }

  get subgraphId(): BigInt {
    let value = this.get("subgraphId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set subgraphId(value: BigInt) {
    this.set("subgraphId", Value.fromBigInt(value));
  }

  get tokenId(): BigInt {
    let value = this.get("tokenId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set tokenId(value: BigInt) {
    this.set("tokenId", Value.fromBigInt(value));
  }

  get hash(): Bytes {
    let value = this.get("hash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set hash(value: Bytes) {
    this.set("hash", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get actions(): ActionLoader {
    return new ActionLoader("Stream", this.get("id")!.toString(), "actions");
  }

  get asset(): string {
    let value = this.get("asset");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set asset(value: string) {
    this.set("asset", Value.fromString(value));
  }

  get assetDecimals(): BigInt {
    let value = this.get("assetDecimals");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set assetDecimals(value: BigInt) {
    this.set("assetDecimals", Value.fromBigInt(value));
  }

  get batch(): string {
    let value = this.get("batch");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set batch(value: string) {
    this.set("batch", Value.fromString(value));
  }

  get category(): string {
    let value = this.get("category");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set category(value: string) {
    this.set("category", Value.fromString(value));
  }

  get contract(): Bytes {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contract(value: Bytes) {
    this.set("contract", Value.fromBytes(value));
  }

  get position(): BigInt {
    let value = this.get("position");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set position(value: BigInt) {
    this.set("position", Value.fromBigInt(value));
  }

  get recipient(): Bytes {
    let value = this.get("recipient");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set recipient(value: Bytes) {
    this.set("recipient", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get startTime(): BigInt {
    let value = this.get("startTime");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set startTime(value: BigInt) {
    this.set("startTime", Value.fromBigInt(value));
  }

  get transferable(): boolean {
    let value = this.get("transferable");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set transferable(value: boolean) {
    this.set("transferable", Value.fromBoolean(value));
  }

  get version(): string {
    let value = this.get("version");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set version(value: string) {
    this.set("version", Value.fromString(value));
  }

  get withdrawnAmount(): BigInt {
    let value = this.get("withdrawnAmount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set withdrawnAmount(value: BigInt) {
    this.set("withdrawnAmount", Value.fromBigInt(value));
  }

  get availableAmount(): BigInt {
    let value = this.get("availableAmount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set availableAmount(value: BigInt) {
    this.set("availableAmount", Value.fromBigInt(value));
  }

  get creator(): Bytes {
    let value = this.get("creator");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set creator(value: Bytes) {
    this.set("creator", Value.fromBytes(value));
  }

  get depletionTime(): BigInt {
    let value = this.get("depletionTime");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set depletionTime(value: BigInt) {
    this.set("depletionTime", Value.fromBigInt(value));
  }

  get depositedAmount(): BigInt {
    let value = this.get("depositedAmount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set depositedAmount(value: BigInt) {
    this.set("depositedAmount", Value.fromBigInt(value));
  }

  get forgivenDebt(): BigInt {
    let value = this.get("forgivenDebt");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set forgivenDebt(value: BigInt) {
    this.set("forgivenDebt", Value.fromBigInt(value));
  }

  get lastAdjustmentAction(): string | null {
    let value = this.get("lastAdjustmentAction");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set lastAdjustmentAction(value: string | null) {
    if (!value) {
      this.unset("lastAdjustmentAction");
    } else {
      this.set("lastAdjustmentAction", Value.fromString(<string>value));
    }
  }

  get lastAdjustmentTimestamp(): BigInt {
    let value = this.get("lastAdjustmentTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set lastAdjustmentTimestamp(value: BigInt) {
    this.set("lastAdjustmentTimestamp", Value.fromBigInt(value));
  }

  get paused(): boolean {
    let value = this.get("paused");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set paused(value: boolean) {
    this.set("paused", Value.fromBoolean(value));
  }

  get pausedAction(): string | null {
    let value = this.get("pausedAction");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set pausedAction(value: string | null) {
    if (!value) {
      this.unset("pausedAction");
    } else {
      this.set("pausedAction", Value.fromString(<string>value));
    }
  }

  get pausedTime(): BigInt | null {
    let value = this.get("pausedTime");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set pausedTime(value: BigInt | null) {
    if (!value) {
      this.unset("pausedTime");
    } else {
      this.set("pausedTime", Value.fromBigInt(<BigInt>value));
    }
  }

  get ratePerSecond(): BigInt {
    let value = this.get("ratePerSecond");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set ratePerSecond(value: BigInt) {
    this.set("ratePerSecond", Value.fromBigInt(value));
  }

  get refundedAmount(): BigInt {
    let value = this.get("refundedAmount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set refundedAmount(value: BigInt) {
    this.set("refundedAmount", Value.fromBigInt(value));
  }

  get snapshotAmount(): BigInt {
    let value = this.get("snapshotAmount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set snapshotAmount(value: BigInt) {
    this.set("snapshotAmount", Value.fromBigInt(value));
  }

  get voided(): boolean {
    let value = this.get("voided");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set voided(value: boolean) {
    this.set("voided", Value.fromBoolean(value));
  }

  get voidedAction(): string | null {
    let value = this.get("voidedAction");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set voidedAction(value: string | null) {
    if (!value) {
      this.unset("voidedAction");
    } else {
      this.set("voidedAction", Value.fromString(<string>value));
    }
  }

  get voidedTime(): BigInt | null {
    let value = this.get("voidedTime");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set voidedTime(value: BigInt | null) {
    if (!value) {
      this.unset("voidedTime");
    } else {
      this.set("voidedTime", Value.fromBigInt(<BigInt>value));
    }
  }
}

export class StreamLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Stream[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Stream[]>(value);
  }
}

export class BatchLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Batch[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Batch[]>(value);
  }
}

export class ActionLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Action[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Action[]>(value);
  }
}

================
File: helpers/amounts.ts
================
import { BigInt } from "@graphprotocol/graph-ts";
import { DECIMALS_18, ONE, TEN } from "../../common/constants";

/**
 * Scale an amount from the ERC20 token's decimals to 18 decimals.
 *
 * Sablier Flow doesn't allow tokens with > 18 decimals.
 * @see https://github.com/sablier-labs/flow/blob/v1.1/src/SablierFlow.sol#L611-L614
 *
 * @param amount The amount to scale, denominated in the ERC20 token's decimals.
 * @param decimals The number of decimals of the ERC20 token.
 * @returns The scaled token amount, denominated in 18 decimals.
 */
export function scale(amount: BigInt, decimals: BigInt): BigInt {
  const delta = DECIMALS_18.minus(decimals).toU32();

  let multiplier = ONE;
  for (let i: u32 = 0; i < delta; i++) {
    multiplier = multiplier.times(TEN);
  }
  return amount.times(multiplier);
}

================
File: helpers/index.ts
================
export * from "./amounts";

================
File: helpers/types.ts
================
import { Address, BigInt } from "@graphprotocol/graph-ts";

export namespace Params {
  export class AdjustFlowStream {
    oldRatePerSecond: BigInt;
    newRatePerSecond: BigInt;
    tokenId: BigInt;
  }

  export class CreateFlowStream {
    ratePerSecond: BigInt;
    recipient: Address;
    sender: Address;
    streamId: BigInt;
    token: Address;
    transferable: boolean;
  }

  export class DepositFlowStream {
    funder: Address;
    streamId: BigInt;
    amount: BigInt;
  }

  export class PauseFlowStream {
    sender: Address;
    recipient: Address;
    streamId: BigInt;
    totalDebt: BigInt;
  }

  export class RefundFromFlowStream {
    sender: Address;
    streamId: BigInt;
    amount: BigInt;
  }

  export class RestartFlowStream {
    sender: Address;
    streamId: BigInt;
    ratePerSecond: BigInt;
  }

  export class Transfer {
    from: Address;
    to: Address;
    tokenId: BigInt;
  }

  export class VoidFlowStream {
    sender: Address;
    recipient: Address;
    streamId: BigInt;
    newTotalDebt: BigInt;
    writtenOffDebt: BigInt;
  }

  export class WithdrawFromFlowStream {
    caller: Address;
    to: Address;
    streamId: BigInt;
    withdrawAmount: BigInt;
  }
}

================
File: manifests/abstract.yaml
================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
specVersion: "1.3.0"
description: "The Graph indexer for Sablier Flow"
repository: "https://github.com/sablier-labs/indexers"
schema:
  file: "../schema.graphql"
dataSources:
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_0"
    network: "abstract"
    context:
      alias:
        data: "FL"
        type: "String"
      chainId:
        data: "2741"
        type: "BigInt"
      version:
        data: "v1.0"
        type: "String"
    source:
      address: "0x001f1408515ccd5c1a19a682455ed4efa39dadd6"
      abi: "SablierFlow"
      startBlock: 73630
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.0/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.0/index.ts"
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_1"
    network: "abstract"
    context:
      alias:
        data: "FL2"
        type: "String"
      chainId:
        data: "2741"
        type: "BigInt"
      version:
        data: "v1.1"
        type: "String"
    source:
      address: "0x555b0766f494c641bb522086da4e728ac08c1420"
      abi: "SablierFlow"
      startBlock: 281608
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.1/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.1/index.ts"

================
File: manifests/arbitrum-one.yaml
================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
specVersion: "1.3.0"
description: "The Graph indexer for Sablier Flow"
repository: "https://github.com/sablier-labs/indexers"
schema:
  file: "../schema.graphql"
dataSources:
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_0"
    network: "arbitrum-one"
    context:
      alias:
        data: "FL"
        type: "String"
      chainId:
        data: "42161"
        type: "BigInt"
      version:
        data: "v1.0"
        type: "String"
    source:
      address: "0x18a12a7035aa56240bcd236bc019aa245dcc015a"
      abi: "SablierFlow"
      startBlock: 281305357
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.0/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.0/index.ts"
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_1"
    network: "arbitrum-one"
    context:
      alias:
        data: "FL2"
        type: "String"
      chainId:
        data: "42161"
        type: "BigInt"
      version:
        data: "v1.1"
        type: "String"
    source:
      address: "0x87cf87ec5de33deb4a88787065373563ba85ee72"
      abi: "SablierFlow"
      startBlock: 299902462
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.1/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.1/index.ts"

================
File: manifests/arbitrum-sepolia.yaml
================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
specVersion: "1.3.0"
description: "The Graph indexer for Sablier Flow"
repository: "https://github.com/sablier-labs/indexers"
schema:
  file: "../schema.graphql"
dataSources:
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_0"
    network: "arbitrum-sepolia"
    context:
      alias:
        data: "FL"
        type: "String"
      chainId:
        data: "421614"
        type: "BigInt"
      version:
        data: "v1.0"
        type: "String"
    source:
      address: "0x781b3b2527f2a0a1e6b429161f2717a8a28b9f46"
      abi: "SablierFlow"
      startBlock: 103460016
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.0/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.0/index.ts"
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_1"
    network: "arbitrum-sepolia"
    context:
      alias:
        data: "FL2"
        type: "String"
      chainId:
        data: "421614"
        type: "BigInt"
      version:
        data: "v1.1"
        type: "String"
    source:
      address: "0xf9cbffae10010475a2800a5efc11f4d4780ca48d"
      abi: "SablierFlow"
      startBlock: 118469567
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.1/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.1/index.ts"

================
File: manifests/avalanche.yaml
================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
specVersion: "1.3.0"
description: "The Graph indexer for Sablier Flow"
repository: "https://github.com/sablier-labs/indexers"
schema:
  file: "../schema.graphql"
dataSources:
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_0"
    network: "avalanche"
    context:
      alias:
        data: "FL"
        type: "String"
      chainId:
        data: "43114"
        type: "BigInt"
      version:
        data: "v1.0"
        type: "String"
    source:
      address: "0x8c172e42c06302e3cfe555dc4d6b71a756ee186b"
      abi: "SablierFlow"
      startBlock: 53922039
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.0/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.0/index.ts"
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_1"
    network: "avalanche"
    context:
      alias:
        data: "FL2"
        type: "String"
      chainId:
        data: "43114"
        type: "BigInt"
      version:
        data: "v1.1"
        type: "String"
    source:
      address: "0xac7cb985d4022a5ebd4a385374ac3d3b487b3c63"
      abi: "SablierFlow"
      startBlock: 56440631
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.1/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.1/index.ts"

================
File: manifests/base-sepolia.yaml
================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
specVersion: "1.3.0"
description: "The Graph indexer for Sablier Flow"
repository: "https://github.com/sablier-labs/indexers"
schema:
  file: "../schema.graphql"
dataSources:
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_0"
    network: "base-sepolia"
    context:
      alias:
        data: "FL"
        type: "String"
      chainId:
        data: "84532"
        type: "BigInt"
      version:
        data: "v1.0"
        type: "String"
    source:
      address: "0xd5f78708d83ac2bc8734a8cdf2d112c1bb3b62a2"
      abi: "SablierFlow"
      startBlock: 18780695
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.0/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.0/index.ts"
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_1"
    network: "base-sepolia"
    context:
      alias:
        data: "FL2"
        type: "String"
      chainId:
        data: "84532"
        type: "BigInt"
      version:
        data: "v1.1"
        type: "String"
    source:
      address: "0xfb6b72a5988a7701a9090c56936269241693a9cc"
      abi: "SablierFlow"
      startBlock: 21117359
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.1/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.1/index.ts"

================
File: manifests/base.yaml
================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
specVersion: "1.3.0"
description: "The Graph indexer for Sablier Flow"
repository: "https://github.com/sablier-labs/indexers"
schema:
  file: "../schema.graphql"
dataSources:
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_0"
    network: "base"
    context:
      alias:
        data: "FL"
        type: "String"
      chainId:
        data: "8453"
        type: "BigInt"
      version:
        data: "v1.0"
        type: "String"
    source:
      address: "0x1a9adc0e2114c8407cc31669baafeee031d15dd2"
      abi: "SablierFlow"
      startBlock: 23269999
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.0/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.0/index.ts"
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_1"
    network: "base"
    context:
      alias:
        data: "FL2"
        type: "String"
      chainId:
        data: "8453"
        type: "BigInt"
      version:
        data: "v1.1"
        type: "String"
    source:
      address: "0x6fe93c7f6cd1dc394e71591e3c42715be7180a6a"
      abi: "SablierFlow"
      startBlock: 25607016
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.1/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.1/index.ts"

================
File: manifests/berachain.yaml
================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
specVersion: "1.3.0"
description: "The Graph indexer for Sablier Flow"
repository: "https://github.com/sablier-labs/indexers"
schema:
  file: "../schema.graphql"
dataSources:
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_1"
    network: "berachain"
    context:
      alias:
        data: "FL2"
        type: "String"
      chainId:
        data: "80094"
        type: "BigInt"
      version:
        data: "v1.1"
        type: "String"
    source:
      address: "0xa031544946ed769377128fbd961c9d621c4b4179"
      abi: "SablierFlow"
      startBlock: 780382
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.1/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.1/index.ts"

================
File: manifests/blast-mainnet.yaml
================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
specVersion: "1.3.0"
description: "The Graph indexer for Sablier Flow"
repository: "https://github.com/sablier-labs/indexers"
schema:
  file: "../schema.graphql"
dataSources:
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_0"
    network: "blast-mainnet"
    context:
      alias:
        data: "FL"
        type: "String"
      chainId:
        data: "81457"
        type: "BigInt"
      version:
        data: "v1.0"
        type: "String"
    source:
      address: "0xfdac2799644141856e20e021ac06f231cafc731f"
      abi: "SablierFlow"
      startBlock: 12259771
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.0/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.0/index.ts"
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_1"
    network: "blast-mainnet"
    context:
      alias:
        data: "FL2"
        type: "String"
      chainId:
        data: "81457"
        type: "BigInt"
      version:
        data: "v1.1"
        type: "String"
    source:
      address: "0x16b50eb5eaef0366f1a4da594e2a8c8943a297e0"
      abi: "SablierFlow"
      startBlock: 14596787
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.1/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.1/index.ts"

================
File: manifests/bsc.yaml
================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
specVersion: "1.3.0"
description: "The Graph indexer for Sablier Flow"
repository: "https://github.com/sablier-labs/indexers"
schema:
  file: "../schema.graphql"
dataSources:
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_0"
    network: "bsc"
    context:
      alias:
        data: "FL"
        type: "String"
      chainId:
        data: "56"
        type: "BigInt"
      version:
        data: "v1.0"
        type: "String"
    source:
      address: "0xfce01f79247cf450062545e7155d7bd568551d0e"
      abi: "SablierFlow"
      startBlock: 44582847
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.0/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.0/index.ts"
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_1"
    network: "bsc"
    context:
      alias:
        data: "FL2"
        type: "String"
      chainId:
        data: "56"
        type: "BigInt"
      version:
        data: "v1.1"
        type: "String"
    source:
      address: "0x4c4610af3f3861ec99b6f6f8066c03e4c3a0e023"
      abi: "SablierFlow"
      startBlock: 46140698
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.1/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.1/index.ts"

================
File: manifests/chiliz.yaml
================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
specVersion: "1.3.0"
description: "The Graph indexer for Sablier Flow"
repository: "https://github.com/sablier-labs/indexers"
schema:
  file: "../schema.graphql"
dataSources:
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_0"
    network: "chiliz"
    context:
      alias:
        data: "FL"
        type: "String"
      chainId:
        data: "88888"
        type: "BigInt"
      version:
        data: "v1.0"
        type: "String"
    source:
      address: "0x9efc8663cab0e2d97ad17c9fbfc8392445517e94"
      abi: "SablierFlow"
      startBlock: 19125673
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.0/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.0/index.ts"
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_1"
    network: "chiliz"
    context:
      alias:
        data: "FL2"
        type: "String"
      chainId:
        data: "88888"
        type: "BigInt"
      version:
        data: "v1.1"
        type: "String"
    source:
      address: "0x28eab88ee8a951f78e1028557d0c3fd97af61a33"
      abi: "SablierFlow"
      startBlock: 20430455
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.1/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.1/index.ts"

================
File: manifests/ethereum.yaml
================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
specVersion: "1.3.0"
description: "The Graph indexer for Sablier Flow"
repository: "https://github.com/sablier-labs/indexers"
schema:
  file: "../schema.graphql"
dataSources:
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_0"
    network: "ethereum"
    context:
      alias:
        data: "FL"
        type: "String"
      chainId:
        data: "1"
        type: "BigInt"
      version:
        data: "v1.0"
        type: "String"
    source:
      address: "0x2d9221a63e12aa796619cb381ec4a71b201281f5"
      abi: "SablierFlow"
      startBlock: 21330577
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.0/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.0/index.ts"
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_1"
    network: "ethereum"
    context:
      alias:
        data: "FL2"
        type: "String"
      chainId:
        data: "1"
        type: "BigInt"
      version:
        data: "v1.1"
        type: "String"
    source:
      address: "0x3df2aaede81d2f6b261f79047517713b8e844e04"
      abi: "SablierFlow"
      startBlock: 21718688
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.1/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.1/index.ts"

================
File: manifests/form.yaml
================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
specVersion: "1.3.0"
description: "The Graph indexer for Sablier Flow"
repository: "https://github.com/sablier-labs/indexers"
schema:
  file: "../schema.graphql"
dataSources:
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_1"
    network: "form"
    context:
      alias:
        data: "FL2"
        type: "String"
      chainId:
        data: "478"
        type: "BigInt"
      version:
        data: "v1.1"
        type: "String"
    source:
      address: "0x5dd399bb320412df92df5c10484d3f8d481fe231"
      abi: "SablierFlow"
      startBlock: 3359543
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.1/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.1/index.ts"

================
File: manifests/gnosis.yaml
================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
specVersion: "1.3.0"
description: "The Graph indexer for Sablier Flow"
repository: "https://github.com/sablier-labs/indexers"
schema:
  file: "../schema.graphql"
dataSources:
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_0"
    network: "gnosis"
    context:
      alias:
        data: "FL"
        type: "String"
      chainId:
        data: "100"
        type: "BigInt"
      version:
        data: "v1.0"
        type: "String"
    source:
      address: "0x5515f774a4db42820802333ba575f68a6e85bd13"
      abi: "SablierFlow"
      startBlock: 37356094
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.0/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.0/index.ts"
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_1"
    network: "gnosis"
    context:
      alias:
        data: "FL2"
        type: "String"
      chainId:
        data: "100"
        type: "BigInt"
      version:
        data: "v1.1"
        type: "String"
    source:
      address: "0x34bc0c2bf1f2da51c65cd821ba4133afcacdb8f5"
      abi: "SablierFlow"
      startBlock: 38258920
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.1/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.1/index.ts"

================
File: manifests/iotex.yaml
================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
specVersion: "1.3.0"
description: "The Graph indexer for Sablier Flow"
repository: "https://github.com/sablier-labs/indexers"
schema:
  file: "../schema.graphql"
dataSources:
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_0"
    network: "iotex"
    context:
      alias:
        data: "FL"
        type: "String"
      chainId:
        data: "4689"
        type: "BigInt"
      version:
        data: "v1.0"
        type: "String"
    source:
      address: "0x1ddc1c21cd39c2fa16366e6036c95342a31831ba"
      abi: "SablierFlow"
      startBlock: 33533023
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.0/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.0/index.ts"
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_1"
    network: "iotex"
    context:
      alias:
        data: "FL2"
        type: "String"
      chainId:
        data: "4689"
        type: "BigInt"
      version:
        data: "v1.1"
        type: "String"
    source:
      address: "0xcd8871a22640c57ba36984fb57e9c794f5df7f40"
      abi: "SablierFlow"
      startBlock: 34453553
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.1/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.1/index.ts"

================
File: manifests/lightlink.yaml
================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
specVersion: "1.3.0"
description: "The Graph indexer for Sablier Flow"
repository: "https://github.com/sablier-labs/indexers"
schema:
  file: "../schema.graphql"
dataSources:
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_0"
    network: "lightlink"
    context:
      alias:
        data: "FL"
        type: "String"
      chainId:
        data: "1890"
        type: "BigInt"
      version:
        data: "v1.0"
        type: "String"
    source:
      address: "0x46fa0164c5af9382d330e5a245a2ca8a18398950"
      abi: "SablierFlow"
      startBlock: 116397460
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.0/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.0/index.ts"
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_1"
    network: "lightlink"
    context:
      alias:
        data: "FL2"
        type: "String"
      chainId:
        data: "1890"
        type: "BigInt"
      version:
        data: "v1.1"
        type: "String"
    source:
      address: "0x89d964e0b508234bcfdc7a32ae0aa0356f422b70"
      abi: "SablierFlow"
      startBlock: 125538058
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.1/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.1/index.ts"

================
File: manifests/linea.yaml
================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
specVersion: "1.3.0"
description: "The Graph indexer for Sablier Flow"
repository: "https://github.com/sablier-labs/indexers"
schema:
  file: "../schema.graphql"
dataSources:
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_0"
    network: "linea"
    context:
      alias:
        data: "FL"
        type: "String"
      chainId:
        data: "59144"
        type: "BigInt"
      version:
        data: "v1.0"
        type: "String"
    source:
      address: "0x949bfa08f1632432a2656a9db17ca34d54da8296"
      abi: "SablierFlow"
      startBlock: 12929891
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.0/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.0/index.ts"
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_1"
    network: "linea"
    context:
      alias:
        data: "FL2"
        type: "String"
      chainId:
        data: "59144"
        type: "BigInt"
      version:
        data: "v1.1"
        type: "String"
    source:
      address: "0xefc6e4c7dc5faa0cfbfebb5e04ea7cd47f64012f"
      abi: "SablierFlow"
      startBlock: 15120566
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.1/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.1/index.ts"

================
File: manifests/mode-mainnet.yaml
================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
specVersion: "1.3.0"
description: "The Graph indexer for Sablier Flow"
repository: "https://github.com/sablier-labs/indexers"
schema:
  file: "../schema.graphql"
dataSources:
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_0"
    network: "mode-mainnet"
    context:
      alias:
        data: "FL"
        type: "String"
      chainId:
        data: "34443"
        type: "BigInt"
      version:
        data: "v1.0"
        type: "String"
    source:
      address: "0x75970dde488431fc4961494569def3269f20d6b3"
      abi: "SablierFlow"
      startBlock: 16616938
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.0/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.0/index.ts"
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_1"
    network: "mode-mainnet"
    context:
      alias:
        data: "FL2"
        type: "String"
      chainId:
        data: "34443"
        type: "BigInt"
      version:
        data: "v1.1"
        type: "String"
    source:
      address: "0xc968e8eefe19bd6de8868df40d9740be127a172a"
      abi: "SablierFlow"
      startBlock: 18917939
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.1/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.1/index.ts"

================
File: manifests/optimism-sepolia.yaml
================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
specVersion: "1.3.0"
description: "The Graph indexer for Sablier Flow"
repository: "https://github.com/sablier-labs/indexers"
schema:
  file: "../schema.graphql"
dataSources:
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_0"
    network: "optimism-sepolia"
    context:
      alias:
        data: "FL"
        type: "String"
      chainId:
        data: "11155420"
        type: "BigInt"
      version:
        data: "v1.0"
        type: "String"
    source:
      address: "0x417db0f2bd020fc4d6bccea6b2bb6be0c541862e"
      abi: "SablierFlow"
      startBlock: 20763576
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.0/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.0/index.ts"
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_1"
    network: "optimism-sepolia"
    context:
      alias:
        data: "FL2"
        type: "String"
      chainId:
        data: "11155420"
        type: "BigInt"
      version:
        data: "v1.1"
        type: "String"
    source:
      address: "0x77873085a88189c8b82b3a01bcbc294108d02805"
      abi: "SablierFlow"
      startBlock: 23100249
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.1/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.1/index.ts"

================
File: manifests/optimism.yaml
================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
specVersion: "1.3.0"
description: "The Graph indexer for Sablier Flow"
repository: "https://github.com/sablier-labs/indexers"
schema:
  file: "../schema.graphql"
dataSources:
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_0"
    network: "optimism"
    context:
      alias:
        data: "FL"
        type: "String"
      chainId:
        data: "10"
        type: "BigInt"
      version:
        data: "v1.0"
        type: "String"
    source:
      address: "0x906356e4e6410ea0a97dbc5b071cf394ab0dcd69"
      abi: "SablierFlow"
      startBlock: 128865315
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.0/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.0/index.ts"
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_1"
    network: "optimism"
    context:
      alias:
        data: "FL2"
        type: "String"
      chainId:
        data: "10"
        type: "BigInt"
      version:
        data: "v1.1"
        type: "String"
    source:
      address: "0xc5612fea2d370127ac67048115bd6b1df7b7f7c0"
      abi: "SablierFlow"
      startBlock: 131202347
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.1/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.1/index.ts"

================
File: manifests/polygon.yaml
================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
specVersion: "1.3.0"
description: "The Graph indexer for Sablier Flow"
repository: "https://github.com/sablier-labs/indexers"
schema:
  file: "../schema.graphql"
dataSources:
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_0"
    network: "polygon"
    context:
      alias:
        data: "FL"
        type: "String"
      chainId:
        data: "137"
        type: "BigInt"
      version:
        data: "v1.0"
        type: "String"
    source:
      address: "0xcf2d812d5aad4e6fec3b05850ff056b21159d496"
      abi: "SablierFlow"
      startBlock: 65079319
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.0/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.0/index.ts"
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_1"
    network: "polygon"
    context:
      alias:
        data: "FL2"
        type: "String"
      chainId:
        data: "137"
        type: "BigInt"
      version:
        data: "v1.1"
        type: "String"
    source:
      address: "0x3e5c4130ea7cfbd364fa5f170289d697865ca94b"
      abi: "SablierFlow"
      startBlock: 67217839
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.1/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.1/index.ts"

================
File: manifests/scroll.yaml
================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
specVersion: "1.3.0"
description: "The Graph indexer for Sablier Flow"
repository: "https://github.com/sablier-labs/indexers"
schema:
  file: "../schema.graphql"
dataSources:
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_0"
    network: "scroll"
    context:
      alias:
        data: "FL"
        type: "String"
      chainId:
        data: "534352"
        type: "BigInt"
      version:
        data: "v1.0"
        type: "String"
    source:
      address: "0x66826f53bffeaab71adc7fe1a77e86f8268848d8"
      abi: "SablierFlow"
      startBlock: 11643209
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.0/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.0/index.ts"
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_1"
    network: "scroll"
    context:
      alias:
        data: "FL2"
        type: "String"
      chainId:
        data: "534352"
        type: "BigInt"
      version:
        data: "v1.1"
        type: "String"
    source:
      address: "0xc4f104ce12cb12484ff67cf0c4bd0561f0014ec2"
      abi: "SablierFlow"
      startBlock: 13011209
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.1/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.1/index.ts"

================
File: manifests/sei-mainnet.yaml
================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
specVersion: "1.3.0"
description: "The Graph indexer for Sablier Flow"
repository: "https://github.com/sablier-labs/indexers"
schema:
  file: "../schema.graphql"
dataSources:
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_1"
    network: "sei-mainnet"
    context:
      alias:
        data: "FL2"
        type: "String"
      chainId:
        data: "1329"
        type: "BigInt"
      version:
        data: "v1.1"
        type: "String"
    source:
      address: "0xdef70082ebda4944a55311624900e42a720b4ec9"
      abi: "SablierFlow"
      startBlock: 138911958
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.1/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.1/index.ts"

================
File: manifests/sepolia.yaml
================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
specVersion: "1.3.0"
description: "The Graph indexer for Sablier Flow"
repository: "https://github.com/sablier-labs/indexers"
schema:
  file: "../schema.graphql"
dataSources:
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_0"
    network: "sepolia"
    context:
      alias:
        data: "FL"
        type: "String"
      chainId:
        data: "11155111"
        type: "BigInt"
      version:
        data: "v1.0"
        type: "String"
    source:
      address: "0x5ae8c13f6ae094887322012425b34b0919097d8a"
      abi: "SablierFlow"
      startBlock: 7210716
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.0/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.0/index.ts"
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_1"
    network: "sepolia"
    context:
      alias:
        data: "FL2"
        type: "String"
      chainId:
        data: "11155111"
        type: "BigInt"
      version:
        data: "v1.1"
        type: "String"
    source:
      address: "0x93fe8f86e881a23e5a2feb4b160514fd332576a6"
      abi: "SablierFlow"
      startBlock: 7583391
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.1/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.1/index.ts"

================
File: manifests/unichain.yaml
================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
specVersion: "1.3.0"
description: "The Graph indexer for Sablier Flow"
repository: "https://github.com/sablier-labs/indexers"
schema:
  file: "../schema.graphql"
dataSources:
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_1"
    network: "unichain"
    context:
      alias:
        data: "FL2"
        type: "String"
      chainId:
        data: "130"
        type: "BigInt"
      version:
        data: "v1.1"
        type: "String"
    source:
      address: "0x9797b40340be0bfc9ec0dbb8712627bcdd17e771"
      abi: "SablierFlow"
      startBlock: 13883575
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.1/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.1/index.ts"

================
File: manifests/xdc.yaml
================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
specVersion: "1.3.0"
description: "The Graph indexer for Sablier Flow"
repository: "https://github.com/sablier-labs/indexers"
schema:
  file: "../schema.graphql"
dataSources:
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_1"
    network: "xdc"
    context:
      alias:
        data: "FL2"
        type: "String"
      chainId:
        data: "50"
        type: "BigInt"
      version:
        data: "v1.1"
        type: "String"
    source:
      address: "0xd6482334242862951da3e730f818c3f6e3f45a30"
      abi: "SablierFlow"
      startBlock: 85226840
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.1/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.1/index.ts"

================
File: manifests/zksync-sepolia.yaml
================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
specVersion: "1.3.0"
description: "The Graph indexer for Sablier Flow"
repository: "https://github.com/sablier-labs/indexers"
schema:
  file: "../schema.graphql"
dataSources:
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_0"
    network: "zksync-sepolia"
    context:
      alias:
        data: "FL"
        type: "String"
      chainId:
        data: "300"
        type: "BigInt"
      version:
        data: "v1.0"
        type: "String"
    source:
      address: "0x8e70296f8972ebe94d885b1caf94da4836976140"
      abi: "SablierFlow"
      startBlock: 4276904
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.0/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.0/index.ts"
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_1"
    network: "zksync-sepolia"
    context:
      alias:
        data: "FL2"
        type: "String"
      chainId:
        data: "300"
        type: "BigInt"
      version:
        data: "v1.1"
        type: "String"
    source:
      address: "0xf499b35e2e932a05ecd6115aa4dcceb29af55e3d"
      abi: "SablierFlow"
      startBlock: 4570709
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.1/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.1/index.ts"

================
File: manifests/zksync.yaml
================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
specVersion: "1.3.0"
description: "The Graph indexer for Sablier Flow"
repository: "https://github.com/sablier-labs/indexers"
schema:
  file: "../schema.graphql"
dataSources:
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_0"
    network: "zksync"
    context:
      alias:
        data: "FL"
        type: "String"
      chainId:
        data: "324"
        type: "BigInt"
      version:
        data: "v1.0"
        type: "String"
    source:
      address: "0x015899a075b7c181e357cd0ed000683dbb4f1fce"
      abi: "SablierFlow"
      startBlock: 50572220
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.0/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.0/index.ts"
  - kind: "ethereum/contract"
    name: "SablierFlow_v1_1"
    network: "zksync"
    context:
      alias:
        data: "FL2"
        type: "String"
      chainId:
        data: "324"
        type: "BigInt"
      version:
        data: "v1.1"
        type: "String"
    source:
      address: "0xe3747379bf7282e0ab5389a63ea053a5256042df"
      abi: "SablierFlow"
      startBlock: 54711342
    mapping:
      apiVersion: "0.0.9"
      kind: "ethereum/events"
      language: "wasm/assemblyscript"
      abis:
        - name: "SablierFlow"
          file: "../../../abi/flow-v1.1/SablierFlow.json"
        - name: "ERC20"
          file: "../../../abi/ERC20.json"
        - name: "ERC20Bytes"
          file: "../../../abi/ERC20Bytes.json"
      entities:
        - "Action"
        - "Asset"
        - "Batch"
        - "Batcher"
        - "Stream"
        - "Watcher"
      eventHandlers:
        - event: "Approval(indexed address,indexed address,indexed uint256)"
          handler: "handleApproval"
        - event: "ApprovalForAll(indexed address,indexed address,bool)"
          handler: "handleApprovalForAll"
        - event: "Transfer(indexed address,indexed address,indexed uint256)"
          handler: "handleTransfer"
        - event: "AdjustFlowStream(indexed uint256,uint256,uint128,uint128)"
          handler: "handleAdjustFlowStream"
        - event: "CreateFlowStream(uint256,indexed address,indexed address,uint128,indexed address,bool)"
          handler: "handleCreateFlowStream"
        - event: "DepositFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleDepositFlowStream"
        - event: "PauseFlowStream(indexed uint256,indexed address,indexed address,uint256)"
          handler: "handlePauseFlowStream"
        - event: "RefundFromFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRefundFromFlowStream"
        - event: "RestartFlowStream(indexed uint256,indexed address,uint128)"
          handler: "handleRestartFlowStream"
        - event: "VoidFlowStream(indexed uint256,indexed address,indexed address,address,uint256,uint256)"
          handler: "handleVoidFlowStream"
        - event: "WithdrawFromFlowStream(indexed uint256,indexed address,indexed address,address,uint128,uint128)"
          handler: "handleWithdrawFromFlowStream"
      file: "../mappings/v1.1/index.ts"

================
File: mappings/common/adjust-stream.ts
================
import { ethereum } from "@graphprotocol/graph-ts";
import { logError } from "../../../common/logger";
import { CommonParams } from "../../../common/types";
import { scale } from "../../helpers";
import { Params } from "../../helpers/types";
import { Store } from "../../store";

export function handleAdjustFlowStream(event: ethereum.Event, params: Params.AdjustFlowStream): void {
  const tokenId = params.tokenId;
  const stream = Store.Stream.get(tokenId);
  if (stream === null) {
    logError("Stream not saved before this AdjustFlowStream event: {}", [tokenId.toHexString()]);
    return;
  }

  /* --------------------------------- STREAM --------------------------------- */
  const now = event.block.timestamp;
  const elapsedTime = now.minus(stream.lastAdjustmentTimestamp);
  const streamedAmount = stream.ratePerSecond.times(elapsedTime);
  const snapshotAmount = stream.snapshotAmount.plus(streamedAmount);

  // The depletion time is recalculated only if the current depletion time is in the future.
  if (stream.depletionTime.gt(now)) {
    const withdrawnAmount = scale(stream.withdrawnAmount, stream.assetDecimals);
    const notWithdrawn = snapshotAmount.minus(withdrawnAmount);
    const availableAmount = scale(stream.availableAmount, stream.assetDecimals);
    const extraAmount = availableAmount.minus(notWithdrawn);
    stream.depletionTime = now.plus(extraAmount.div(params.newRatePerSecond));
  }

  stream.lastAdjustmentTimestamp = now;
  stream.ratePerSecond = params.newRatePerSecond;
  stream.snapshotAmount = snapshotAmount;

  /* --------------------------------- ACTION --------------------------------- */
  const action = Store.Action.create(event, {
    amountA: params.oldRatePerSecond,
    amountB: params.newRatePerSecond,
    category: "Adjust",
    streamId: stream.id,
  } as CommonParams.Action);
  stream.lastAdjustmentAction = action.id;
  stream.save();
}

================
File: mappings/common/approval-for-all.ts
================
import { ethereum } from "@graphprotocol/graph-ts";
import { ONE, ZERO } from "../../../common/constants";
import { CommonParams } from "../../../common/types";
import { Store } from "../../store";

export function handleApprovalForAll(event: ethereum.Event, params: CommonParams.ApprovalForAll): void {
  Store.Action.create(event, {
    addressA: params.owner,
    addressB: params.operator,
    amountA: params.approved ? ONE : ZERO,
    category: "ApprovalForAll",
  } as CommonParams.Action);
}

================
File: mappings/common/approval.ts
================
import { ethereum } from "@graphprotocol/graph-ts";
import { logInfo } from "../../../common/logger";
import { CommonParams } from "../../../common/types";
import { Store } from "../../store";

export function handleApproval(event: ethereum.Event, params: CommonParams.Approval): void {
  const id = params.tokenId;
  const stream = Store.Stream.get(id);
  if (stream === null) {
    logInfo("Stream not saved before this Approval event: {}", [id.toHexString()]);
    return;
  }

  Store.Action.create(event, {
    addressA: params.owner,
    addressB: params.approved,
    category: "Approval",
    streamId: stream.id,
  } as CommonParams.Action);
}

================
File: mappings/common/create-stream.ts
================
import { ethereum } from "@graphprotocol/graph-ts";
import { CommonParams } from "../../../common/types";
import { Params } from "../../helpers/types";
import { Store } from "../../store";

export function handleCreateFlowStream(event: ethereum.Event, params: Params.CreateFlowStream): void {
  const stream = Store.Stream.create(event, {
    ratePerSecond: params.ratePerSecond,
    recipient: params.recipient,
    sender: params.sender,
    streamId: params.streamId,
    token: params.token,
    transferable: params.transferable,
  });
  Store.Action.create(event, {
    addressA: params.sender,
    addressB: params.recipient,
    amountA: params.ratePerSecond,
    category: "Create",
    streamId: stream.id,
  } as CommonParams.Action);
}

================
File: mappings/common/deposit-stream.ts
================
import { ethereum } from "@graphprotocol/graph-ts";
import { logError } from "../../../common/logger";
import { CommonParams } from "../../../common/types";
import { scale } from "../../helpers";
import { Params } from "../../helpers/types";
import { Store } from "../../store";

export function handleDepositFlowStream(event: ethereum.Event, params: Params.DepositFlowStream): void {
  const id = params.streamId;
  const stream = Store.Stream.get(id);
  if (stream === null) {
    logError("Stream not saved before this DepositFlowStream event: {}", [id.toHexString()]);
    return;
  }

  /* --------------------------------- STREAM --------------------------------- */
  stream.depositedAmount = stream.depositedAmount.plus(params.amount);
  stream.availableAmount = stream.availableAmount.plus(params.amount);
  const availableAmount = scale(stream.availableAmount, stream.assetDecimals);

  const now = event.block.timestamp;
  const elapsedTime = now.minus(stream.lastAdjustmentTimestamp);
  const snapshotAmount = stream.snapshotAmount.plus(stream.ratePerSecond.times(elapsedTime));
  const withdrawnAmount = scale(stream.withdrawnAmount, stream.assetDecimals);
  const notWithdrawnAmount = snapshotAmount.minus(withdrawnAmount);

  // If the stream still has debt, mimic the contract behavior.
  if (availableAmount.gt(notWithdrawnAmount)) {
    const extraAmount = availableAmount.minus(notWithdrawnAmount);

    if (stream.ratePerSecond.isZero() === false) {
      stream.depletionTime = now.plus(extraAmount.div(stream.ratePerSecond));
    }
  }
  stream.save();

  /* --------------------------------- ACTION --------------------------------- */
  Store.Action.create(event, {
    addressA: params.funder,
    amountA: params.amount,
    category: "Deposit",
    streamId: stream.id,
  } as CommonParams.Action);
}

================
File: mappings/common/index.ts
================
export { handleAdjustFlowStream } from "./adjust-stream";
export { handleApproval } from "./approval";
export { handleApprovalForAll } from "./approval-for-all";
export { handleCreateFlowStream } from "./create-stream";
export { handleDepositFlowStream } from "./deposit-stream";
export { handlePauseFlowStream } from "./pause-stream";
export { handleRefundFromFlowStream } from "./refund-stream";
export { handleRestartFlowStream } from "./restart-stream";
export { handleTransfer } from "./transfer";
export { handleVoidFlowStream } from "./void-stream";
export { handleWithdrawFromFlowStream } from "./withdraw-stream";

================
File: mappings/common/pause-stream.ts
================
import { ethereum } from "@graphprotocol/graph-ts";
import { ZERO } from "../../../common/constants";
import { logError } from "../../../common/logger";
import { CommonParams } from "../../../common/types";
import { Params } from "../../helpers/types";
import { Store } from "../../store";

export function handlePauseFlowStream(event: ethereum.Event, params: Params.PauseFlowStream): void {
  const id = params.streamId;
  const stream = Store.Stream.get(id);
  if (stream === null) {
    logError("Stream not saved before this Pause event: {}", [id.toHexString()]);
    return;
  }

  /* --------------------------------- STREAM --------------------------------- */

  // Paused is actually an adjustment with the new rate set to zero.
  const now = event.block.timestamp;
  const elapsedTime = now.minus(stream.lastAdjustmentTimestamp);
  const streamedAmount = stream.ratePerSecond.times(elapsedTime);
  const snapshotAmount = stream.snapshotAmount.plus(streamedAmount);

  stream.lastAdjustmentTimestamp = now;
  stream.paused = true;
  stream.pausedTime = now;
  stream.ratePerSecond = ZERO;
  stream.snapshotAmount = snapshotAmount;

  /* --------------------------------- ACTION --------------------------------- */
  const action = Store.Action.create(event, {
    addressA: params.recipient,
    addressB: params.sender,
    amountA: params.totalDebt,
    category: "Pause",
    streamId: stream.id,
  } as CommonParams.Action);
  stream.lastAdjustmentAction = action.id;
  stream.pausedAction = action.id;
  stream.save();
}

================
File: mappings/common/refund-stream.ts
================
import { ethereum } from "@graphprotocol/graph-ts";
import { ZERO } from "../../../common/constants";
import { logError } from "../../../common/logger";
import { CommonParams } from "../../../common/types";
import { scale } from "../../helpers";
import { Params } from "../../helpers/types";
import { Store } from "../../store";

export function handleRefundFromFlowStream(event: ethereum.Event, params: Params.RefundFromFlowStream): void {
  const id = params.streamId;
  const stream = Store.Stream.get(id);
  if (stream === null) {
    logError("Stream not saved before this Refund event: {}", [id.toHexString()]);
    return;
  }

  /* --------------------------------- STREAM --------------------------------- */
  stream.refundedAmount = stream.refundedAmount.plus(params.amount);
  stream.availableAmount = stream.availableAmount.minus(params.amount);

  const now = event.block.timestamp;
  const availableAmount = scale(stream.availableAmount, stream.assetDecimals);
  const elapsedTime = now.minus(stream.lastAdjustmentTimestamp);
  const streamedAmount = stream.ratePerSecond.times(elapsedTime);
  const snapshotAmount = stream.snapshotAmount.plus(streamedAmount);
  const withdrawnAmount = scale(stream.withdrawnAmount, stream.assetDecimals);
  const notWithdrawnAmount = snapshotAmount.minus(withdrawnAmount);

  // If the entire available amount is refunded, the stream starts accruing now.
  const extraAmount = availableAmount.minus(notWithdrawnAmount);
  const depletionTime = now;
  if (extraAmount.notEqual(ZERO) || stream.ratePerSecond.notEqual(ZERO)) {
    stream.depletionTime = now.plus(extraAmount.div(stream.ratePerSecond));
  }
  stream.depletionTime = depletionTime;
  stream.save();

  /* --------------------------------- ACTION --------------------------------- */
  Store.Action.create(event, {
    addressA: params.sender,
    amountA: params.amount,
    category: "Refund",
    streamId: stream.id,
  } as CommonParams.Action);
}

================
File: mappings/common/restart-stream.ts
================
import { ethereum } from "@graphprotocol/graph-ts";
import { logError } from "../../../common/logger";
import { CommonParams } from "../../../common/types";
import { scale } from "../../helpers";
import { Params } from "../../helpers/types";
import { Store } from "../../store";

export function handleRestartFlowStream(event: ethereum.Event, params: Params.RestartFlowStream): void {
  const id = params.streamId;
  const stream = Store.Stream.get(id);
  if (stream === null) {
    logError("Stream not saved before this Restart event: {}", [id.toHexString()]);
    return;
  }

  /* --------------------------------- STREAM --------------------------------- */

  // Restart is actually an adjustment.
  const availableAmount = scale(stream.availableAmount, stream.assetDecimals);
  const withdrawnAmount = scale(stream.withdrawnAmount, stream.assetDecimals);
  const notWithdrawnAmount = stream.snapshotAmount.minus(withdrawnAmount);

  const now = event.block.timestamp;
  let depletionTime = now;
  if (availableAmount.gt(notWithdrawnAmount)) {
    const extraAmount = availableAmount.minus(notWithdrawnAmount);
    depletionTime = now.plus(extraAmount.div(stream.ratePerSecond));
  }
  stream.depletionTime = depletionTime;
  stream.lastAdjustmentTimestamp = now;
  stream.paused = false;
  stream.pausedTime = null;
  stream.pausedAction = null;
  stream.ratePerSecond = params.ratePerSecond;

  /* --------------------------------- ACTION --------------------------------- */
  const action = Store.Action.create(event, {
    addressA: params.sender,
    amountA: params.ratePerSecond,
    category: "Restart",
    streamId: stream.id,
  } as CommonParams.Action);
  stream.lastAdjustmentAction = action.id;
  stream.save();
}

================
File: mappings/common/transfer.ts
================
import { ethereum } from "@graphprotocol/graph-ts";
import { ADDRESS_ZERO } from "../../../common/constants";
import { logError } from "../../../common/logger";
import { CommonParams } from "../../../common/types";
import { Params } from "../../helpers/types";
import { Store } from "../../store";

export function handleTransfer(event: ethereum.Event, params: Params.Transfer): void {
  // We exclude `Transfer` events emitted by the initial mint transaction.
  // See https://github.com/sablier-labs/indexers/issues/18
  if (params.from.equals(ADDRESS_ZERO)) {
    return;
  }

  const tokenId = params.tokenId;
  const stream = Store.Stream.get(tokenId);
  if (stream === null) {
    logError("Stream not saved before this Transfer event: {}", [tokenId.toHexString()]);
    return;
  }

  /* --------------------------------- STREAM --------------------------------- */
  const oldRecipient = params.from;
  const newRecipient = params.to;
  stream.recipient = newRecipient;
  stream.save();

  /* --------------------------------- ACTION --------------------------------- */
  Store.Action.create(event, {
    addressA: oldRecipient,
    addressB: newRecipient,
    category: "Transfer",
    streamId: stream.id,
  } as CommonParams.Action);
}

================
File: mappings/common/void-stream.ts
================
import { ethereum } from "@graphprotocol/graph-ts";
import { ZERO } from "../../../common/constants";
import { logError } from "../../../common/logger";
import { CommonParams } from "../../../common/types";
import { scale } from "../../helpers";
import { Params } from "../../helpers/types";
import { Store } from "../../store";

export function handleVoidFlowStream(event: ethereum.Event, params: Params.VoidFlowStream): void {
  const id = params.streamId;
  const stream = Store.Stream.get(id);
  if (stream === null) {
    logError("Stream not saved before this VoidFlowStream event: {}", [id.toHexString()]);
    return;
  }

  /* --------------------------------- STREAM --------------------------------- */

  // Void is actually an adjustment with the new rate set to zero.
  const now = event.block.timestamp;
  const elapsedTime = now.minus(stream.lastAdjustmentTimestamp);
  const streamedAmount = stream.ratePerSecond.times(elapsedTime);
  const snapshotAmount = stream.snapshotAmount.plus(streamedAmount);

  const withdrawnAmount = scale(stream.withdrawnAmount, stream.assetDecimals);
  const availableAmount = scale(stream.availableAmount, stream.assetDecimals);
  const maxAvailable = withdrawnAmount.plus(availableAmount);

  stream.depletionTime = ZERO;
  stream.forgivenDebt = params.writtenOffDebt;
  stream.lastAdjustmentTimestamp = now;
  stream.paused = true;
  stream.pausedTime = now;
  stream.ratePerSecond = ZERO;
  stream.snapshotAmount = maxAvailable.lt(snapshotAmount) ? maxAvailable : snapshotAmount;
  stream.voidedTime = now;
  stream.voided = true;

  /* --------------------------------- ACTION --------------------------------- */
  const action = Store.Action.create(event, {
    addressA: params.recipient,
    addressB: params.sender,
    amountA: params.newTotalDebt,
    amountB: params.writtenOffDebt,
    category: "Void",
    streamId: stream.id,
  } as CommonParams.Action);
  stream.lastAdjustmentAction = action.id;
  stream.pausedAction = action.id;
  stream.voidedAction = action.id;
  stream.save();
}

================
File: mappings/common/withdraw-stream.ts
================
import { ethereum } from "@graphprotocol/graph-ts";
import { logError } from "../../../common/logger";
import { CommonParams } from "../../../common/types";
import { Params } from "../../helpers/types";
import { Store } from "../../store";

export function handleWithdrawFromFlowStream(event: ethereum.Event, params: Params.WithdrawFromFlowStream): void {
  const id = params.streamId;
  const stream = Store.Stream.get(id);
  if (stream === null) {
    logError("Stream not saved before this WithdrawFromFlowStream event: {}", [id.toHexString()]);
    return;
  }

  /* --------------------------------- STREAM --------------------------------- */
  stream.availableAmount = stream.availableAmount.minus(params.withdrawAmount);
  stream.withdrawnAmount = stream.withdrawnAmount.plus(params.withdrawAmount);
  stream.save();

  /* --------------------------------- ACTION --------------------------------- */
  Store.Action.create(event, {
    addressA: params.caller,
    addressB: params.to,
    amountA: params.withdrawAmount,
    category: "Withdraw",
    streamId: stream.id,
  } as CommonParams.Action);
}

================
File: mappings/v1.0/index.ts
================
import {
  AdjustFlowStream as Adjust_v1_0,
  Approval as Approval_v1_0,
  ApprovalForAll as ApprovalForAll_v1_0,
  CreateFlowStream as Create_v1_0,
  DepositFlowStream as Deposit_v1_0,
  PauseFlowStream as Pause_v1_0,
  RefundFromFlowStream as Refund_v1_0,
  RestartFlowStream as Restart_v1_0,
  Transfer as Transfer_v1_0,
  VoidFlowStream as Void_v1_0,
  WithdrawFromFlowStream as Withdraw_v1_0,
} from "../../bindings/SablierFlow_v1_0/SablierFlow";

import {
  handleAdjustFlowStream,
  handleApproval,
  handleApprovalForAll,
  handleCreateFlowStream,
  handleDepositFlowStream,
  handlePauseFlowStream,
  handleRefundFromFlowStream,
  handleRestartFlowStream,
  handleTransfer,
  handleVoidFlowStream,
  handleWithdrawFromFlowStream,
} from "../common";

export function handleAdjustFlowStream_v1_0(event: Adjust_v1_0): void {
  handleAdjustFlowStream(event, {
    newRatePerSecond: event.params.newRatePerSecond,
    oldRatePerSecond: event.params.oldRatePerSecond,
    tokenId: event.params.streamId,
  });
}

export function handleApproval_v1_0(event: Approval_v1_0): void {
  const params = { ...event.params };
  handleApproval(event, params);
}

export function handleApprovalForAll_v1_0(event: ApprovalForAll_v1_0): void {
  handleApprovalForAll(event, {
    approved: event.params.approved,
    operator: event.params.operator,
    owner: event.params.owner,
  });
}

export function handleCreateFlowStream_v1_0(event: Create_v1_0): void {
  handleCreateFlowStream(event, {
    ratePerSecond: event.params.ratePerSecond,
    recipient: event.params.recipient,
    sender: event.params.sender,
    streamId: event.params.streamId,
    token: event.params.token,
    transferable: event.params.transferable,
  });
}

export function handleDepositFlowStream_v1_0(event: Deposit_v1_0): void {
  handleDepositFlowStream(event, {
    amount: event.params.amount,
    funder: event.params.funder,
    streamId: event.params.streamId,
  });
}

export function handlePauseFlowStream_v1_0(event: Pause_v1_0): void {
  handlePauseFlowStream(event, {
    recipient: event.params.recipient,
    sender: event.params.sender,
    streamId: event.params.streamId,
    totalDebt: event.params.totalDebt,
  });
}

export function handleRefundFromFlowStream_v1_0(event: Refund_v1_0): void {
  handleRefundFromFlowStream(event, {
    amount: event.params.amount,
    sender: event.params.sender,
    streamId: event.params.streamId,
  });
}

export function handleRestartFlowStream_v1_0(event: Restart_v1_0): void {
  handleRestartFlowStream(event, {
    ratePerSecond: event.params.ratePerSecond,
    sender: event.params.sender,
    streamId: event.params.streamId,
  });
}

export function handleTransfer_v1_0(event: Transfer_v1_0): void {
  handleTransfer(event, {
    from: event.params.from,
    to: event.params.to,
    tokenId: event.params.tokenId,
  });
}

export function handleVoidFlowStream_v1_0(event: Void_v1_0): void {
  handleVoidFlowStream(event, {
    newTotalDebt: event.params.newTotalDebt,
    recipient: event.params.recipient,
    sender: event.params.sender,
    streamId: event.params.streamId,
    writtenOffDebt: event.params.writtenOffDebt,
  });
}

export function handleWithdrawFromFlowStream_v1_0(event: Withdraw_v1_0): void {
  handleWithdrawFromFlowStream(event, {
    caller: event.params.caller,
    streamId: event.params.streamId,
    to: event.params.to,
    withdrawAmount: event.params.withdrawAmount,
  });
}

================
File: mappings/v1.1/index.ts
================
import {
  AdjustFlowStream as Adjust_v1_1,
  Approval as Approval_v1_1,
  ApprovalForAll as ApprovalForAll_v1_1,
  CreateFlowStream as Create_v1_1,
  DepositFlowStream as Deposit_v1_1,
  PauseFlowStream as Pause_v1_1,
  RefundFromFlowStream as Refund_v1_1,
  RestartFlowStream as Restart_v1_1,
  Transfer as Transfer_v1_1,
  VoidFlowStream as Void_v1_1,
  WithdrawFromFlowStream as Withdraw_v1_1,
} from "../../bindings/SablierFlow_v1_1/SablierFlow";

import {
  handleAdjustFlowStream,
  handleApproval,
  handleApprovalForAll,
  handleCreateFlowStream,
  handleDepositFlowStream,
  handlePauseFlowStream,
  handleRefundFromFlowStream,
  handleRestartFlowStream,
  handleTransfer,
  handleVoidFlowStream,
  handleWithdrawFromFlowStream,
} from "../common";

export function handleAdjustFlowStream_v1_1(event: Adjust_v1_1): void {
  handleAdjustFlowStream(event, {
    newRatePerSecond: event.params.newRatePerSecond,
    oldRatePerSecond: event.params.oldRatePerSecond,
    tokenId: event.params.streamId,
  });
}

export function handleApproval_v1_1(event: Approval_v1_1): void {
  handleApproval(event, {
    approved: event.params.approved,
    owner: event.params.owner,
    tokenId: event.params.tokenId,
  });
}

export function handleApprovalForAll_v1_1(event: ApprovalForAll_v1_1): void {
  handleApprovalForAll(event, {
    approved: event.params.approved,
    operator: event.params.operator,
    owner: event.params.owner,
  });
}

export function handleCreateFlowStream_v1_1(event: Create_v1_1): void {
  handleCreateFlowStream(event, {
    ratePerSecond: event.params.ratePerSecond,
    recipient: event.params.recipient,
    sender: event.params.sender,
    streamId: event.params.streamId,
    token: event.params.token,
    transferable: event.params.transferable,
  });
}

export function handleDepositFlowStream_v1_1(event: Deposit_v1_1): void {
  handleDepositFlowStream(event, {
    amount: event.params.amount,
    funder: event.params.funder,
    streamId: event.params.streamId,
  });
}

export function handlePauseFlowStream_v1_1(event: Pause_v1_1): void {
  handlePauseFlowStream(event, {
    recipient: event.params.recipient,
    sender: event.params.sender,
    streamId: event.params.streamId,
    totalDebt: event.params.totalDebt,
  });
}

export function handleRefundFromFlowStream_v1_1(event: Refund_v1_1): void {
  handleRefundFromFlowStream(event, {
    amount: event.params.amount,
    sender: event.params.sender,
    streamId: event.params.streamId,
  });
}

export function handleRestartFlowStream_v1_1(event: Restart_v1_1): void {
  handleRestartFlowStream(event, {
    ratePerSecond: event.params.ratePerSecond,
    sender: event.params.sender,
    streamId: event.params.streamId,
  });
}

export function handleTransfer_v1_1(event: Transfer_v1_1): void {
  handleTransfer(event, {
    from: event.params.from,
    to: event.params.to,
    tokenId: event.params.tokenId,
  });
}

export function handleVoidFlowStream_v1_1(event: Void_v1_1): void {
  handleVoidFlowStream(event, {
    newTotalDebt: event.params.newTotalDebt,
    recipient: event.params.recipient,
    sender: event.params.sender,
    streamId: event.params.streamId,
    writtenOffDebt: event.params.writtenOffDebt,
  });
}

export function handleWithdrawFromFlowStream_v1_1(event: Withdraw_v1_1): void {
  handleWithdrawFromFlowStream(event, {
    caller: event.params.caller,
    streamId: event.params.streamId,
    to: event.params.to,
    withdrawAmount: event.params.withdrawAmount,
  });
}

================
File: store/entity-action.ts
================
import { ethereum } from "@graphprotocol/graph-ts";
import { ONE } from "../../common/constants";
import { readChainId } from "../../common/context";
import { Id } from "../../common/id";
import { CommonParams } from "../../common/types";
import { EntityAction } from "../bindings";
import { getOrCreateWatcher } from "./entity-watcher";

export function createAction(event: ethereum.Event, params: CommonParams.Action): EntityAction {
  const id = Id.action(event);
  const action = new EntityAction(id);
  const watcher = getOrCreateWatcher();

  /* --------------------------- ACTION: TRANSACTION -------------------------- */
  action.block = event.block.number;
  action.chainId = readChainId();
  action.contract = event.address;
  action.fee = event.transaction.value;
  action.from = event.transaction.from;
  action.hash = event.transaction.hash;
  action.subgraphId = watcher.actionCounter;
  action.timestamp = event.block.timestamp;

  /* ----------------------------- ACTION: PARAMS ----------------------------- */
  action.addressA = params.addressA;
  action.addressB = params.addressB;
  action.amountA = params.amountA;
  action.amountB = params.amountB;
  action.category = params.category;
  action.stream = params.streamId;
  action.save();

  /* --------------------------------- WATCHER -------------------------------- */
  watcher.actionCounter = watcher.actionCounter.plus(ONE);
  watcher.save();

  return action;
}

================
File: store/entity-asset.ts
================
import { Address, BigInt } from "@graphprotocol/graph-ts";
import { ERC20 } from "../../common/bindings";
import { getAssetName, getAssetSymbol } from "../../common/bindings/getters";
import { readChainId } from "../../common/context";
import { Id } from "../../common/id";
import { EntityAsset } from "../bindings";

export function getOrCreateAsset(address: Address): EntityAsset {
  const id = Id.asset(address);
  let asset = EntityAsset.load(id);

  if (asset === null) {
    asset = new EntityAsset(id);

    const erc20 = ERC20.bind(address);
    const decimals = erc20.decimals();

    asset.address = address;
    asset.chainId = readChainId();
    asset.decimals = BigInt.fromI32(decimals);
    asset.name = getAssetName(address);
    asset.symbol = getAssetSymbol(address);

    asset.save();
  }

  return asset;
}

================
File: store/entity-batch.ts
================
import { Address, ethereum } from "@graphprotocol/graph-ts";
import { ONE, TWO, ZERO } from "../../common/constants";
import { Id } from "../../common/id";
import { EntityBatch } from "../bindings";
import { getOrCreateBatcher } from "./entity-batcher";
/**
 * This function may be run multiple times within the same transaction:
 *
 * 1. For the 1st stream, the Batch entity is created with a size of zero and all other fields null.
 * 2. For the 2nd stream, all fields are set.
 * 3. For the 3rd stream and later, only the size is updated.
 *
 * The rationale is that creating the batch entity makes sense only if there are at least 2 streams.
 */
export function getOrCreateBatch(event: ethereum.Event, sender: Address): EntityBatch {
  const id = Id.batch(event.transaction.hash, sender);
  const batcher = getOrCreateBatcher(sender);

  let batch = EntityBatch.load(id);
  if (batch === null) {
    batch = new EntityBatch(id);
    batch.size = ZERO;
  } else {
    const hash = batch.hash;
    if (hash === null) {
      batch.batcher = batcher.id;
      batch.hash = event.transaction.hash;
      batch.size = TWO;
      batch.timestamp = event.block.timestamp;
    } else {
      batch.size = batch.size.plus(ONE);
      batcher.batchCounter = batcher.batchCounter.plus(ONE);
      batcher.save();
    }
  }

  batch.save();
  return batch;
}

================
File: store/entity-batcher.ts
================
import { Address } from "@graphprotocol/graph-ts";
import { ZERO } from "../../common/constants";
import { EntityBatcher } from "../bindings";

export function getOrCreateBatcher(sender: Address): EntityBatcher {
  const id = sender.toHexString();
  let batcher = EntityBatcher.load(id);

  if (batcher === null) {
    batcher = new EntityBatcher(id);
    batcher.batchCounter = ZERO;
    batcher.save();
  }

  return batcher;
}

================
File: store/entity-stream.ts
================
import { BigInt, dataSource, ethereum } from "@graphprotocol/graph-ts";
import { ONE, ZERO } from "../../common/constants";
import { readChainId, readContractVersion } from "../../common/context";
import { Id } from "../../common/id";
import { EntityStream } from "../bindings";
import { Params } from "../helpers/types";
import { getOrCreateAsset } from "./entity-asset";
import { getOrCreateBatch } from "./entity-batch";
import { getOrCreateWatcher } from "./entity-watcher";

export function createStream(event: ethereum.Event, params: Params.CreateFlowStream): EntityStream {
  const chainId = readChainId();
  const tokenId = params.streamId;
  const streamId = Id.stream(dataSource.address(), tokenId);
  const stream = new EntityStream(streamId);
  const watcher = getOrCreateWatcher();

  /* --------------------------------- WATCHER -------------------------------- */
  stream.subgraphId = watcher.streamCounter;
  watcher.streamCounter = watcher.streamCounter.plus(ONE);
  watcher.save();

  /* --------------------------------- ASSET --------------------------------- */
  const asset = getOrCreateAsset(params.token);
  stream.asset = asset.id;
  stream.assetDecimals = asset.decimals;

  /* --------------------------------- BATCH --------------------------------- */
  const batch = getOrCreateBatch(event, params.sender);
  stream.batch = batch.id;
  stream.position = batch.size.minus(ONE);

  /* ------------------------------ STREAM: PARAMS ------------------------------ */
  stream.alias = Id.streamAlias(chainId, tokenId);
  stream.category = "Flow";
  stream.chainId = chainId;
  stream.contract = event.address;
  stream.creator = event.transaction.from;
  stream.depletionTime = event.block.timestamp;
  stream.hash = event.transaction.hash;
  stream.lastAdjustmentTimestamp = event.block.timestamp;
  stream.ratePerSecond = params.ratePerSecond;
  stream.recipient = params.recipient;
  stream.startTime = event.block.timestamp;
  stream.sender = params.sender;
  stream.timestamp = event.block.timestamp;
  stream.tokenId = tokenId;
  stream.transferable = params.transferable;
  stream.version = readContractVersion();

  /* ------------------------------ STREAM: DEFAULTS ----------------------------- */
  stream.availableAmount = ZERO;
  stream.depositedAmount = ZERO;
  stream.forgivenDebt = ZERO;
  stream.paused = false;
  stream.refundedAmount = ZERO;
  stream.snapshotAmount = ZERO;
  stream.voided = false;
  stream.withdrawnAmount = ZERO;
  stream.save();

  return stream;
}

export function getStream(tokenId: BigInt): EntityStream | null {
  const flowAddress = dataSource.address();
  const id = Id.stream(flowAddress, tokenId);
  return EntityStream.load(id);
}

================
File: store/entity-watcher.ts
================
import { ONE } from "../../common/constants";
import { readChainId } from "../../common/context";
import { EntityWatcher } from "../bindings";

export function getOrCreateWatcher(): EntityWatcher {
  const chainId = readChainId();
  let watcher = EntityWatcher.load(chainId.toString());

  if (watcher === null) {
    watcher = new EntityWatcher(chainId.toString());
    watcher.actionCounter = ONE;
    watcher.chainId = chainId;
    watcher.streamCounter = ONE;
  }

  return watcher;
}

================
File: store/index.ts
================
import { createAction } from "./entity-action";
import { getOrCreateAsset } from "./entity-asset";
import { getOrCreateBatch } from "./entity-batch";
import { getOrCreateBatcher } from "./entity-batcher";
import { createStream, getStream } from "./entity-stream";
import { getOrCreateWatcher } from "./entity-watcher";

export namespace Store {
  export namespace Action {
    export const create = createAction;
  }

  export namespace Asset {
    export const getOrCreate = getOrCreateAsset;
  }

  export namespace Batch {
    export const getOrCreate = getOrCreateBatch;
  }

  export namespace Batcher {
    export const getOrCreate = getOrCreateBatcher;
  }

  export namespace Stream {
    export const create = createStream;
    export const get = getStream;
  }

  export namespace Watcher {
    export const getOrCreate = getOrCreateWatcher;
  }
}

================
File: bindings.ts
================
// Entities
export {
  Action as EntityAction,
  Asset as EntityAsset,
  Batch as EntityBatch,
  Batcher as EntityBatcher,
  Stream as EntityStream,
  Watcher as EntityWatcher,
} from "./bindings/schema";

================
File: schema.graphql
================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
"""
A generic entity for tracking protocol actions. There may be multiple actions for a single tx.
"""
type Action @entity(immutable: true) {
  """Unique identifier: {txHash}-{blockLogIndex}"""
  id: String!
  """Unique global id as tracked by the `Watcher` entity."""
  subgraphId: BigInt!
  """Block number of the Ethereum transaction."""
  block: BigInt!
  """The id of the chain, e.g. 137 for Polygon."""
  chainId: BigInt!
  """The msg.sender of the Ethereum transaction."""
  from: Bytes!
  """Hash of the Ethereum transaction."""
  hash: Bytes!
  """Unix timestamp of the Ethereum transaction."""
  timestamp: BigInt!
  """Category of action, e.g., Deposit."""
  category: ActionCategory!
  """Contract through which the action was triggered."""
  contract: Bytes!
  """
  The Sablier fee paid in the native token of the chain, e.g., ETH for Ethereum Mainnet.
  See https://docs.sablier.com/concepts/fees
  """
  fee: BigInt
  """Stream linked to this action, if any."""
  stream: Stream
  """
  Address of 1st actor. Who this is depends upon the action type, e.g. for Create, it is the sender.
  """
  addressA: Bytes
  """
  Address of 2nd actor. Who this is depends upon the action type, e.g. for Transfer, it is the recipient.
  """
  addressB: Bytes
  """
  1st amount. What this is depends upon the action type, e.g. for Deposit, it is the deposit amount.
  """
  amountA: BigInt
  """
  2nd amount. What this is depends upon the action type, e.g. for Withdraw, it is the refund amount.
  """
  amountB: BigInt
}

"""
Creating streams in bulk is possible using the SablierBatchLockup contract.
See https://github.com/sablier-labs/lockup/blob/v2.0.1/src/SablierBatchLockup.sol

The entity can be immutable because a batch is only updated in the same block.
See https://thegraph.com/docs/en/subgraphs/developing/creating/ql-schema/#defining-entities
"""
type Batch @entity(immutable: true) {
  """Unique identifier: {chainId}-{txHash}-{batcher}"""
  id: String!
  """Hash of the Ethereum transaction that created this batch."""
  hash: Bytes
  """Timestamp of the transaction that created this batch."""
  timestamp: BigInt
  """The sender address that created this batch."""
  batcher: Batcher
  """Number of streams part of this batch."""
  size: BigInt!
  """Streams part of this batch."""
  streams: [Stream!]! @derivedFrom(field: "batch")
}

"""Sender address that created batches."""
type Batcher @entity(immutable: false) {
  """Unique identifier: {chainId}-{sender}"""
  id: String!
  """Numerical index."""
  batchCounter: BigInt!
  """Batches started by this sender."""
  batches: [Batch!]! @derivedFrom(field: "batcher")
}

enum ActionCategory {
  Approval
  ApprovalForAll
  Adjust
  Create
  Deposit
  Pause
  Refund
  Restart
  Transfer
  Void
  Withdraw
}

enum StreamCategory {
  Flow
}

"""ERC-20 asset"""
type Asset @entity(immutable: true) {
  """Contract address of the ERC20 token"""
  id: ID!
  """Alias for id"""
  address: Bytes!
  """The id of the chain, e.g. 137 for Polygon"""
  chainId: BigInt!
  """Decimals of the ERC20 token"""
  decimals: BigInt!
  """Name of the ERC20 token"""
  name: String!
  """Symbol of the ERC20 token"""
  symbol: String!
  """Streams that rely on this token"""
  streams: [Stream!]! @derivedFrom(field: "asset")
}

type Watcher @entity(immutable: false) {
  """The chain ID. There is one watcher per subgraph."""
  id: String!
  """Global counter for actions."""
  actionCounter: BigInt!
  """Alias for id."""
  chainId: BigInt!
  """Used for debugging purposes. They are normally empty."""
  logs: [String!]
  """Global counter."""
  streamCounter: BigInt!
}

type Stream @entity(immutable: false) {
  """Unique identifier: {contractAddress}-{chainId}-{tokenId}"""
  id: String!
  """Like the id: {contractAlias}-{chainId}-{tokenId}"""
  alias: String!
  """The id of the chain, e.g., 137 for Polygon."""
  chainId: BigInt!
  """
  Unique global id as tracked by the `Watcher` entity.
  🚨 This may change if new data sources are added and the chronological order of streams changes.
  """
  subgraphId: BigInt!
  """The id provided by the Lockup contract. This is the ERC-721 tokenId."""
  tokenId: BigInt!
  """Hash of the Ethereum transaction that created this stream."""
  hash: Bytes!
  """Unix timestamp of the Ethereum transaction that created this stream."""
  timestamp: BigInt!
  """Actions triggered by this stream."""
  actions: [Action!]! @derivedFrom(field: "stream")
  """ERC-20 token distributed via this stream."""
  asset: Asset!
  """
  ERC-20 token decimals. Stored here to avoid loading the asset entity on each stream.
  """
  assetDecimals: BigInt!
  """
  The batch the stream may be part of.
  Note: this is available only when created within a batch create transaction.
  """
  batch: Batch!
  """Category used for sorting."""
  category: StreamCategory!
  """The contract the stream originates from."""
  contract: Bytes!
  """Position in the batch, if available."""
  position: BigInt!
  """
  Current recipient of the stream, with permission to withdraw funds to any third-party address.
  Note: the recipient can change on NFT transfer.
  """
  recipient: Bytes!
  """Manager of the stream, with ability to cancel the stream."""
  sender: Bytes!
  """Unix timestamp for the start of the stream."""
  startTime: BigInt!
  """
  Flag indicating the transferability of the stream. This is set when the stream is created, and cannot
  be changed later.
  """
  transferable: Boolean!
  """Version of contract, e.g., v1.0."""
  version: String!
  """The sum of all withdrawn amounts."""
  withdrawnAmount: BigInt!
  """
  This is equivalent to the value returned by ERC20.balanceOf, and it changes after deposit and withdrawal.
  """
  availableAmount: BigInt!
  """
  The account that created the stream, which can be different from the sender.
  """
  creator: Bytes!
  """
  Unix timestamp indicating the time when the stream will become insolvent.
  """
  depletionTime: BigInt!
  """The sum of all deposits."""
  depositedAmount: BigInt!
  """The amount of debt forgiven by a void action."""
  forgivenDebt: BigInt!
  """Action in which the payment rate was adjusted."""
  lastAdjustmentAction: Action
  """Unix timestamp for when the payment rate was adjusted."""
  lastAdjustmentTimestamp: BigInt!
  """Flag indicating if a stream is paused."""
  paused: Boolean!
  """Action in which the stream was paused."""
  pausedAction: Action
  """Unix timestamp for when the stream was paused."""
  pausedTime: BigInt
  """Current payment rate per second, denominated in 18 decimals."""
  ratePerSecond: BigInt!
  """The sum of all refunds."""
  refundedAmount: BigInt!
  """
  The amount streamed up until the time of the last adjustment, denominated in 18 decimals.
  """
  snapshotAmount: BigInt!
  """Flag indicating if a stream is voided."""
  voided: Boolean!
  """Action in which the stream was voided."""
  voidedAction: Action
  """Unix timestamp for when the stream was voided."""
  voidedTime: BigInt
}

================
File: justfile
================
import "../scripts.just"

# Set protocol name

export PROTOCOL := "flow"

# Show available commands
default:
    @just --list




================================================================
End of Codebase
================================================================
